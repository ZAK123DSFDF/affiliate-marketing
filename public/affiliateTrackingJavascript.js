(function (require$$0, require$$3, require$$5, require$$1) {
   'use strict';

   // Generated ESM version of ua-parser-js
   // DO NOT EDIT THIS FILE!
   // Source: /src/main/ua-parser.js

   /////////////////////////////////////////////////////////////////////////////////
   /* UAParser.js v2.0.4
      Copyright Â© 2012-2025 Faisal Salman <f@faisalman.com>
      AGPLv3 License *//*
      Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.
      Supports browser & node.js environment. 
      Demo   : https://uaparser.dev
      Source : https://github.com/faisalman/ua-parser-js */
   /////////////////////////////////////////////////////////////////////////////////

   /* jshint esversion: 6 */ 
   /* globals window */


       
       //////////////
       // Constants
       /////////////

       var LIBVERSION  = '2.0.4',
           UA_MAX_LENGTH = 500,
           USER_AGENT  = 'user-agent',
           EMPTY       = '',
           UNKNOWN     = '?',

           // typeof
           FUNC_TYPE   = 'function',
           UNDEF_TYPE  = 'undefined',
           OBJ_TYPE    = 'object',
           STR_TYPE    = 'string',

           // properties
           UA_BROWSER  = 'browser',
           UA_CPU      = 'cpu',
           UA_DEVICE   = 'device',
           UA_ENGINE   = 'engine',
           UA_OS       = 'os',
           UA_RESULT   = 'result',
           
           NAME        = 'name',
           TYPE        = 'type',
           VENDOR      = 'vendor',
           VERSION     = 'version',
           ARCHITECTURE= 'architecture',
           MAJOR       = 'major',
           MODEL       = 'model',

           // device types
           CONSOLE     = 'console',
           MOBILE      = 'mobile',
           TABLET      = 'tablet',
           SMARTTV     = 'smarttv',
           WEARABLE    = 'wearable',
           XR          = 'xr',
           EMBEDDED    = 'embedded',

           // browser types
           INAPP       = 'inapp',

           // client hints
           BRANDS      = 'brands',
           FORMFACTORS = 'formFactors',
           FULLVERLIST = 'fullVersionList',
           PLATFORM    = 'platform',
           PLATFORMVER = 'platformVersion',
           BITNESS     = 'bitness',
           CH_HEADER   = 'sec-ch-ua',
           CH_HEADER_FULL_VER_LIST = CH_HEADER + '-full-version-list',
           CH_HEADER_ARCH      = CH_HEADER + '-arch',
           CH_HEADER_BITNESS   = CH_HEADER + '-' + BITNESS,
           CH_HEADER_FORM_FACTORS = CH_HEADER + '-form-factors',
           CH_HEADER_MOBILE    = CH_HEADER + '-' + MOBILE,
           CH_HEADER_MODEL     = CH_HEADER + '-' + MODEL,
           CH_HEADER_PLATFORM  = CH_HEADER + '-' + PLATFORM,
           CH_HEADER_PLATFORM_VER = CH_HEADER_PLATFORM + '-version',
           CH_ALL_VALUES       = [BRANDS, FULLVERLIST, MOBILE, MODEL, PLATFORM, PLATFORMVER, ARCHITECTURE, FORMFACTORS, BITNESS],

           // device vendors
           AMAZON      = 'Amazon',
           APPLE       = 'Apple',
           ASUS        = 'ASUS',
           BLACKBERRY  = 'BlackBerry',
           GOOGLE      = 'Google',
           HUAWEI      = 'Huawei',
           LENOVO      = 'Lenovo',
           HONOR       = 'Honor',
           LG          = 'LG',
           MICROSOFT   = 'Microsoft',
           MOTOROLA    = 'Motorola',
           NVIDIA      = 'Nvidia',
           ONEPLUS     = 'OnePlus',
           OPPO        = 'OPPO',
           SAMSUNG     = 'Samsung',
           SHARP       = 'Sharp',
           SONY        = 'Sony',
           XIAOMI      = 'Xiaomi',
           ZEBRA       = 'Zebra',

           // browsers
           CHROME      = 'Chrome',
           CHROMIUM    = 'Chromium',
           CHROMECAST  = 'Chromecast',
           EDGE        = 'Edge',
           FIREFOX     = 'Firefox',
           OPERA       = 'Opera',
           FACEBOOK    = 'Facebook',
           SOGOU       = 'Sogou',

           PREFIX_MOBILE  = 'Mobile ',
           SUFFIX_BROWSER = ' Browser',

           // os
           WINDOWS     = 'Windows';
      
       var isWindow            = typeof window !== UNDEF_TYPE,
           NAVIGATOR           = (isWindow && window.navigator) ? 
                                   window.navigator : 
                                   undefined,
           NAVIGATOR_UADATA    = (NAVIGATOR && NAVIGATOR.userAgentData) ? 
                                   NAVIGATOR.userAgentData : 
                                   undefined;

       ///////////
       // Helper
       //////////

       var extend = function (defaultRgx, extensions) {
               var mergedRgx = {};
               var extraRgx = extensions;
               if (!isExtensions(extensions)) {
                   extraRgx = {};
                   for (var i in extensions) {
                       for (var j in extensions[i]) {
                           extraRgx[j] = extensions[i][j].concat(extraRgx[j] ? extraRgx[j] : []);
                       }
                   }
               }
               for (var k in defaultRgx) {
                   mergedRgx[k] = extraRgx[k] && extraRgx[k].length % 2 === 0 ? extraRgx[k].concat(defaultRgx[k]) : defaultRgx[k];
               }
               return mergedRgx;
           },
           enumerize = function (arr) {
               var enums = {};
               for (var i=0; i<arr.length; i++) {
                   enums[arr[i].toUpperCase()] = arr[i];
               }
               return enums;
           },
           has = function (str1, str2) {
               if (typeof str1 === OBJ_TYPE && str1.length > 0) {
                   for (var i in str1) {
                       if (lowerize(str2) == lowerize(str1[i])) return true;
                   }
                   return false;
               }
               return isString(str1) ? lowerize(str2) == lowerize(str1) : false;
           },
           isExtensions = function (obj, deep) {
               for (var prop in obj) {
                   return /^(browser|cpu|device|engine|os)$/.test(prop) || (deep ? isExtensions(obj[prop]) : false);
               }
           },
           isString = function (val) {
               return typeof val === STR_TYPE;
           },
           itemListToArray = function (header) {
               if (!header) return undefined;
               var arr = [];
               var tokens = strip(/\\?\"/g, header).split(',');
               for (var i = 0; i < tokens.length; i++) {
                   if (tokens[i].indexOf(';') > -1) {
                       var token = trim(tokens[i]).split(';v=');
                       arr[i] = { brand : token[0], version : token[1] };
                   } else {
                       arr[i] = trim(tokens[i]);
                   }
               }
               return arr;
           },
           lowerize = function (str) {
               return isString(str) ? str.toLowerCase() : str;
           },
           majorize = function (version) {
               return isString(version) ? strip(/[^\d\.]/g, version).split('.')[0] : undefined;
           },
           setProps = function (arr) {
               for (var i in arr) {
                   var propName = arr[i];
                   if (typeof propName == OBJ_TYPE && propName.length == 2) {
                       this[propName[0]] = propName[1];
                   } else {
                       this[propName] = undefined;
                   }
               }
               return this;
           },
           strip = function (pattern, str) {
               return isString(str) ? str.replace(pattern, EMPTY) : str;
           },
           stripQuotes = function (str) {
               return strip(/\\?\"/g, str); 
           },
           trim = function (str, len) {
               if (isString(str)) {
                   str = strip(/^\s\s*/, str);
                   return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
               }
       };

       ///////////////
       // Map helper
       //////////////

       var rgxMapper = function (ua, arrays) {

               if(!ua || !arrays) return;

               var i = 0, j, k, p, q, matches, match;

               // loop through all regexes maps
               while (i < arrays.length && !matches) {

                   var regex = arrays[i],       // even sequence (0,2,4,..)
                       props = arrays[i + 1];   // odd sequence (1,3,5,..)
                   j = k = 0;

                   // try matching uastring with regexes
                   while (j < regex.length && !matches) {

                       if (!regex[j]) { break; }
                       matches = regex[j++].exec(ua);

                       if (!!matches) {
                           for (p = 0; p < props.length; p++) {
                               match = matches[++k];
                               q = props[p];
                               // check if given property is actually array
                               if (typeof q === OBJ_TYPE && q.length > 0) {
                                   if (q.length === 2) {
                                       if (typeof q[1] == FUNC_TYPE) {
                                           // assign modified match
                                           this[q[0]] = q[1].call(this, match);
                                       } else {
                                           // assign given value, ignore regex match
                                           this[q[0]] = q[1];
                                       }
                                   } else if (q.length >= 3) {
                                       // Check whether q[1] FUNCTION or REGEX
                                       if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                           if (q.length > 3) {
                                               this[q[0]] = match ? q[1].apply(this, q.slice(2)) : undefined;
                                           } else {
                                               // call function (usually string mapper)
                                               this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                                           }
                                       } else {
                                           if (q.length == 3) {
                                               // sanitize match using given regex
                                               this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                                           } else if (q.length == 4) {
                                               this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                                           } else if (q.length > 4) {
                                               this[q[0]] = match ? q[3].apply(this, [match.replace(q[1], q[2])].concat(q.slice(4))) : undefined;
                                           }
                                       }
                                   }
                               } else {
                                   this[q] = match ? match : undefined;
                               }
                           }
                       }
                   }
                   i += 2;
               }
           },

           strMapper = function (str, map) {

               for (var i in map) {
                   // check if current value is array
                   if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                       for (var j = 0; j < map[i].length; j++) {
                           if (has(map[i][j], str)) {
                               return (i === UNKNOWN) ? undefined : i;
                           }
                       }
                   } else if (has(map[i], str)) {
                       return (i === UNKNOWN) ? undefined : i;
                   }
               }
               return map.hasOwnProperty('*') ? map['*'] : str;
       };

       ///////////////
       // String map
       //////////////

       var windowsVersionMap = {
               'ME'    : '4.90',
               'NT 3.51': '3.51',
               'NT 4.0': '4.0',
               '2000'  : ['5.0', '5.01'],
               'XP'    : ['5.1', '5.2'],
               'Vista' : '6.0',
               '7'     : '6.1',
               '8'     : '6.2',
               '8.1'   : '6.3',
               '10'    : ['6.4', '10.0'],
               'NT'    : ''
           },
           
           formFactorsMap = {
               'embedded'  : 'Automotive',
               'mobile'    : 'Mobile',
               'tablet'    : ['Tablet', 'EInk'],
               'smarttv'   : 'TV',
               'wearable'  : 'Watch',
               'xr'        : ['VR', 'XR'],
               '?'         : ['Desktop', 'Unknown'],
               '*'         : undefined
           },

           browserHintsMap = {
               'Chrome'        : 'Google Chrome',
               'Edge'          : 'Microsoft Edge',
               'Edge WebView2' : 'Microsoft Edge WebView2',
               'Chrome WebView': 'Android WebView',
               'Chrome Headless':'HeadlessChrome',
               'Huawei Browser': 'HuaweiBrowser',
               'MIUI Browser'  : 'Miui Browser',
               'Opera Mobi'    : 'OperaMobile',
               'Yandex'        : 'YaBrowser'
       };

       //////////////
       // Regex map
       /////////////

       var defaultRegexes = {

           browser : [[

               // Most common regardless engine
               /\b(?:crmo|crios)\/([\w\.]+)/i                                      // Chrome for Android/iOS
               ], [VERSION, [NAME, PREFIX_MOBILE + 'Chrome']], [
               /webview.+edge\/([\w\.]+)/i                                         // Microsoft Edge
               ], [VERSION, [NAME, EDGE+' WebView']], [
               /edg(?:e|ios|a)?\/([\w\.]+)/i                                       
               ], [VERSION, [NAME, 'Edge']], [

               // Presto based
               /(opera mini)\/([-\w\.]+)/i,                                        // Opera Mini
               /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,                 // Opera Mobi/Tablet
               /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i                           // Opera
               ], [NAME, VERSION], [
               /opios[\/ ]+([\w\.]+)/i                                             // Opera mini on iphone >= 8.0
               ], [VERSION, [NAME, OPERA+' Mini']], [
               /\bop(?:rg)?x\/([\w\.]+)/i                                          // Opera GX
               ], [VERSION, [NAME, OPERA+' GX']], [
               /\bopr\/([\w\.]+)/i                                                 // Opera Webkit
               ], [VERSION, [NAME, OPERA]], [

               // Mixed
               /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i            // Baidu
               ], [VERSION, [NAME, 'Baidu']], [
               /\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i                       // Maxthon
               ], [VERSION, [NAME, 'Maxthon']], [
               /(kindle)\/([\w\.]+)/i,                                             // Kindle
               /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,      
                                                                                   // Lunascape/Maxthon/Netfront/Jasmine/Blazer/Sleipnir
               // Trident based
               /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i,        // Avant/IEMobile/SlimBrowser/SlimBoat/Slimjet
               /(?:ms|\()(ie) ([\w\.]+)/i,                                         // Internet Explorer

               // Blink/Webkit/KHTML based                                         // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon/LG Browser/Otter/qutebrowser/Dooble
               /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon|otter|dooble|(?:lg |qute)browser)\/([-\w\.]+)/i,
                                                                                   // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ//Vivaldi/DuckDuckGo/Klar/Helio/Dragon
               /(heytap|ovi|115|surf)browser\/([\d\.]+)/i,                         // HeyTap/Ovi/115/Surf
               /(ecosia|weibo)(?:__| \w+@)([\d\.]+)/i                              // Ecosia/Weibo
               ], [NAME, VERSION], [
               /quark(?:pc)?\/([-\w\.]+)/i                                         // Quark
               ], [VERSION, [NAME, 'Quark']], [
               /\bddg\/([\w\.]+)/i                                                 // DuckDuckGo
               ], [VERSION, [NAME, 'DuckDuckGo']], [
               /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i                 // UCBrowser
               ], [VERSION, [NAME, 'UCBrowser']], [
               /microm.+\bqbcore\/([\w\.]+)/i,                                     // WeChat Desktop for Windows Built-in Browser
               /\bqbcore\/([\w\.]+).+microm/i,
               /micromessenger\/([\w\.]+)/i                                        // WeChat
               ], [VERSION, [NAME, 'WeChat']], [
               /konqueror\/([\w\.]+)/i                                             // Konqueror
               ], [VERSION, [NAME, 'Konqueror']], [
               /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i                       // IE11
               ], [VERSION, [NAME, 'IE']], [
               /ya(?:search)?browser\/([\w\.]+)/i                                  // Yandex
               ], [VERSION, [NAME, 'Yandex']], [
               /slbrowser\/([\w\.]+)/i                                             // Smart Lenovo Browser
               ], [VERSION, [NAME, 'Smart ' + LENOVO + SUFFIX_BROWSER]], [
               /(avast|avg)\/([\w\.]+)/i                                           // Avast/AVG Secure Browser
               ], [[NAME, /(.+)/, '$1 Secure' + SUFFIX_BROWSER], VERSION], [
               /\bfocus\/([\w\.]+)/i                                               // Firefox Focus
               ], [VERSION, [NAME, FIREFOX+' Focus']], [
               /\bopt\/([\w\.]+)/i                                                 // Opera Touch
               ], [VERSION, [NAME, OPERA+' Touch']], [
               /coc_coc\w+\/([\w\.]+)/i                                            // Coc Coc Browser
               ], [VERSION, [NAME, 'Coc Coc']], [
               /dolfin\/([\w\.]+)/i                                                // Dolphin
               ], [VERSION, [NAME, 'Dolphin']], [
               /coast\/([\w\.]+)/i                                                 // Opera Coast
               ], [VERSION, [NAME, OPERA+' Coast']], [
               /miuibrowser\/([\w\.]+)/i                                           // MIUI Browser
               ], [VERSION, [NAME, 'MIUI' + SUFFIX_BROWSER]], [
               /fxios\/([\w\.-]+)/i                                                // Firefox for iOS
               ], [VERSION, [NAME, PREFIX_MOBILE + FIREFOX]], [
               /\bqihoobrowser\/?([\w\.]*)/i                                       // 360
               ], [VERSION, [NAME, '360']], [
               /\b(qq)\/([\w\.]+)/i                                                // QQ
               ], [[NAME, /(.+)/, '$1Browser'], VERSION], [
               /(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i
               ], [[NAME, /(.+)/, '$1' + SUFFIX_BROWSER], VERSION], [              // Oculus/Sailfish/HuaweiBrowser/VivoBrowser/PicoBrowser
               /samsungbrowser\/([\w\.]+)/i                                        // Samsung Internet
               ], [VERSION, [NAME, SAMSUNG + ' Internet']], [
               /metasr[\/ ]?([\d\.]+)/i                                            // Sogou Explorer
               ], [VERSION, [NAME, SOGOU + ' Explorer']], [
               /(sogou)mo\w+\/([\d\.]+)/i                                          // Sogou Mobile
               ], [[NAME, SOGOU + ' Mobile'], VERSION], [
               /(electron)\/([\w\.]+) safari/i,                                    // Electron-based App
               /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,                   // Tesla
               /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i   // QQ/2345
               ], [NAME, VERSION], [
               /(lbbrowser|rekonq)/i                                               // LieBao Browser/Rekonq
               ], [NAME], [
               /ome\/([\w\.]+) \w* ?(iron) saf/i,                                  // Iron
               /ome\/([\w\.]+).+qihu (360)[es]e/i                                  // 360
               ], [VERSION, NAME], [

               // WebView
               /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i       // Facebook App for iOS & Android
               ], [[NAME, FACEBOOK], VERSION, [TYPE, INAPP]], [
               /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,                             // Kakao App
               /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,                                  // Naver InApp
               /(daum)apps[\/ ]([\w\.]+)/i,                                        // Daum App
               /safari (line)\/([\w\.]+)/i,                                        // Line App for iOS
               /\b(line)\/([\w\.]+)\/iab/i,                                        // Line App for Android
               /(alipay)client\/([\w\.]+)/i,                                       // Alipay
               /(twitter)(?:and| f.+e\/([\w\.]+))/i,                               // Twitter
               /(instagram|snapchat|klarna)[\/ ]([-\w\.]+)/i                       // Instagram/Snapchat/Klarna
               ], [NAME, VERSION, [TYPE, INAPP]], [
               /\bgsa\/([\w\.]+) .*safari\//i                                      // Google Search Appliance on iOS
               ], [VERSION, [NAME, 'GSA'], [TYPE, INAPP]], [
               /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i                        // TikTok
               ], [VERSION, [NAME, 'TikTok'], [TYPE, INAPP]], [
               /\[(linkedin)app\]/i                                                // LinkedIn App for iOS & Android
               ], [NAME, [TYPE, INAPP]], [

               /(chromium)[\/ ]([-\w\.]+)/i                                        // Chromium
               ], [NAME, VERSION], [

               /headlesschrome(?:\/([\w\.]+)| )/i                                  // Chrome Headless
               ], [VERSION, [NAME, CHROME+' Headless']], [

               /wv\).+chrome\/([\w\.]+).+edgw\//i                                  // Edge WebView2
               ], [VERSION, [NAME, EDGE+' WebView2']], [

               / wv\).+(chrome)\/([\w\.]+)/i                                       // Chrome WebView
               ], [[NAME, CHROME+' WebView'], VERSION], [

               /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i           // Android Browser
               ], [VERSION, [NAME, 'Android' + SUFFIX_BROWSER]], [

               /chrome\/([\w\.]+) mobile/i                                         // Chrome Mobile
               ], [VERSION, [NAME, PREFIX_MOBILE + 'Chrome']], [

               /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i       // Chrome/OmniWeb/Arora/Tizen/Nokia
               ], [NAME, VERSION], [

               /version\/([\w\.\,]+) .*mobile(?:\/\w+ | ?)safari/i                 // Safari Mobile
               ], [VERSION, [NAME, PREFIX_MOBILE + 'Safari']], [
               /iphone .*mobile(?:\/\w+ | ?)safari/i
               ], [[NAME, PREFIX_MOBILE + 'Safari']], [
               /version\/([\w\.\,]+) .*(safari)/i                                  // Safari
               ], [VERSION, NAME], [
               /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i                      // Safari < 3.0
               ], [NAME, [VERSION, '1']], [

               /(webkit|khtml)\/([\w\.]+)/i
               ], [NAME, VERSION], [

               // Gecko based
               /(?:mobile|tablet);.*(firefox)\/([\w\.-]+)/i                        // Firefox Mobile
               ], [[NAME, PREFIX_MOBILE + FIREFOX], VERSION], [
               /(navigator|netscape\d?)\/([-\w\.]+)/i                              // Netscape
               ], [[NAME, 'Netscape'], VERSION], [
               /(wolvic|librewolf)\/([\w\.]+)/i                                    // Wolvic/LibreWolf
               ], [NAME, VERSION], [
               /mobile vr; rv:([\w\.]+)\).+firefox/i                               // Firefox Reality
               ], [VERSION, [NAME, FIREFOX+' Reality']], [
               /ekiohf.+(flow)\/([\w\.]+)/i,                                       // Flow
               /(swiftfox)/i,                                                      // Swiftfox
               /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,
                                                                                   // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
               /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                                                                                   // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
               /(firefox)\/([\w\.]+)/i,                                            // Other Firefox-based
               /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,                         // Mozilla

               // Other
               /(amaya|dillo|doris|icab|ladybird|lynx|mosaic|netsurf|obigo|polaris|w3m|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                                                                                   // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Obigo/Mosaic/Go/ICE/UP.Browser/Ladybird
               /\b(links) \(([\w\.]+)/i                                            // Links
               ], [NAME, [VERSION, /_/g, '.']], [
               
               /(cobalt)\/([\w\.]+)/i                                              // Cobalt
               ], [NAME, [VERSION, /[^\d\.]+./, EMPTY]]
           ],

           cpu : [[

               /\b((amd|x|x86[-_]?|wow|win)64)\b/i                                 // AMD64 (x64)
               ], [[ARCHITECTURE, 'amd64']], [

               /(ia32(?=;))/i,                                                     // IA32 (quicktime)
               /\b((i[346]|x)86)(pc)?\b/i                                          // IA32 (x86)
               ], [[ARCHITECTURE, 'ia32']], [

               /\b(aarch64|arm(v?[89]e?l?|_?64))\b/i                               // ARM64
               ], [[ARCHITECTURE, 'arm64']], [

               /\b(arm(v[67])?ht?n?[fl]p?)\b/i                                     // ARMHF
               ], [[ARCHITECTURE, 'armhf']], [

               // PocketPC mistakenly identified as PowerPC
               /( (ce|mobile); ppc;|\/[\w\.]+arm\b)/i
               ], [[ARCHITECTURE, 'arm']], [

               /((ppc|powerpc)(64)?)( mac|;|\))/i                                  // PowerPC
               ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [

               / sun4\w[;\)]/i                                                     // SPARC
               ], [[ARCHITECTURE, 'sparc']], [

               /\b(avr32|ia64(?=;)|68k(?=\))|\barm(?=v([1-7]|[5-7]1)l?|;|eabi)|(irix|mips|sparc)(64)?\b|pa-risc)/i
                                                                                   // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
               ], [[ARCHITECTURE, lowerize]]
           ],

           device : [[

               //////////////////////////
               // MOBILES & TABLETS
               /////////////////////////

               // Samsung
               /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
               ], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [
               /\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
               /samsung[- ]((?!sm-[lr]|browser)[-\w]+)/i,
               /sec-(sgh\w+)/i
               ], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [

               // Apple
               /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i                          // iPod/iPhone
               ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [
               /\((ipad);[-\w\),; ]+apple/i,                                       // iPad
               /applecoremedia\/[\w\.]+ \((ipad)/i,
               /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
               ], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [
               /(macintosh);/i
               ], [MODEL, [VENDOR, APPLE]], [

               // Sharp
               /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
               ], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [

               // Honor
               /\b((?:brt|eln|hey2?|gdi|jdn)-a?[lnw]09|(?:ag[rm]3?|jdn2|kob2)-a?[lw]0[09]hn)(?: bui|\)|;)/i
               ], [MODEL, [VENDOR, HONOR], [TYPE, TABLET]], [
               /honor([-\w ]+)[;\)]/i
               ], [MODEL, [VENDOR, HONOR], [TYPE, MOBILE]], [

               // Huawei
               /\b((?:ag[rs][2356]?k?|bah[234]?|bg[2o]|bt[kv]|cmr|cpn|db[ry]2?|jdn2|got|kob2?k?|mon|pce|scm|sht?|[tw]gr|vrd)-[ad]?[lw][0125][09]b?|605hw|bg2-u03|(?:gem|fdr|m2|ple|t1)-[7a]0[1-4][lu]|t1-a2[13][lw]|mediapad[\w\. ]*(?= bui|\)))\b(?!.+d\/s)/i
               ], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [
               /(?:huawei)([-\w ]+)[;\)]/i,
               /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
               ], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [

               // Xiaomi
               /oid[^\)]+; (2[\dbc]{4}(182|283|rp\w{2})[cgl]|m2105k81a?c)(?: bui|\))/i,
               /\b((?:red)?mi[-_ ]?pad[\w- ]*)(?: bui|\))/i                                // Mi Pad tablets
               ],[[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, TABLET]], [

               /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,                  // Xiaomi POCO
               /\b; (\w+) build\/hm\1/i,                                           // Xiaomi Hongmi 'numeric' models
               /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,                             // Xiaomi Hongmi
               /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,                   // Xiaomi Redmi
               /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,        // Xiaomi Redmi 'numeric' models
               /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i, // Xiaomi Mi
               / ([\w ]+) miui\/v?\d/i
               ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, MOBILE]], [

               // OnePlus
               /droid.+; (cph2[3-6]\d[13579]|((gm|hd)19|(ac|be|in|kb)20|(d[en]|eb|le|mt)21|ne22)[0-2]\d|p[g-k]\w[1m]10)\b/i,
               /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
               ], [MODEL, [VENDOR, ONEPLUS], [TYPE, MOBILE]], [

               // OPPO
               /; (\w+) bui.+ oppo/i,
               /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
               ], [MODEL, [VENDOR, OPPO], [TYPE, MOBILE]], [
               /\b(opd2(\d{3}a?))(?: bui|\))/i
               ], [MODEL, [VENDOR, strMapper, { 'OnePlus' : ['203', '304', '403', '404', '413', '415'], '*' : OPPO }], [TYPE, TABLET]], [

               // BLU
               /(vivo (5r?|6|8l?|go|one|s|x[il]?[2-4]?)[\w\+ ]*)(?: bui|\))/i  // Vivo series
               ], [MODEL, [VENDOR, 'BLU'], [TYPE, MOBILE]], [    

               // Vivo
               /; vivo (\w+)(?: bui|\))/i,
               /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
               ], [MODEL, [VENDOR, 'Vivo'], [TYPE, MOBILE]], [

               // Realme
               /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
               ], [MODEL, [VENDOR, 'Realme'], [TYPE, MOBILE]], [

               // Lenovo
               /(ideatab[-\w ]+|602lv|d-42a|a101lv|a2109a|a3500-hv|s[56]000|pb-6505[my]|tb-?x?\d{3,4}(?:f[cu]|xu|[av])|yt\d?-[jx]?\d+[lfmx])( bui|;|\)|\/)/i,
               /lenovo ?(b[68]0[08]0-?[hf]?|tab(?:[\w- ]+?)|tb[\w-]{6,7})( bui|;|\)|\/)/i
               ], [MODEL, [VENDOR, LENOVO], [TYPE, TABLET]], [            
               /lenovo[-_ ]?([-\w ]+?)(?: bui|\)|\/)/i
               ], [MODEL, [VENDOR, LENOVO], [TYPE, MOBILE]], [

               // Motorola
               /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
               /\bmot(?:orola)?[- ]([\w\s]+)(\)| bui)/i,
               /((?:moto(?! 360)[-\w\(\) ]+|xt\d{3,4}[cgkosw\+]?[-\d]*|nexus 6)(?= bui|\)))/i
               ], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [
               /\b(mz60\d|xoom[2 ]{0,2}) build\//i
               ], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [

               // LG
               /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
               ], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [
               /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
               /\blg[-e;\/ ]+(?!.*(?:browser|netcast|android tv|watch|webos))(\w+)/i,
               /\blg-?([\d\w]+) bui/i
               ], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [

               // Nokia
               /(nokia) (t[12][01])/i
               ], [VENDOR, MODEL, [TYPE, TABLET]], [
               /(?:maemo|nokia).*(n900|lumia \d+|rm-\d+)/i,
               /nokia[-_ ]?(([-\w\. ]*))/i
               ], [[MODEL, /_/g, ' '], [TYPE, MOBILE], [VENDOR, 'Nokia']], [

               // Google
               /(pixel (c|tablet))\b/i                                             // Google Pixel C/Tablet
               ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [
                                                                                   // Google Pixel
               /droid.+;(?: google)? (g(01[13]a|020[aem]|025[jn]|1b60|1f8f|2ybb|4s1m|576d|5nz6|8hhn|8vou|a02099|c15s|d1yq|e2ae|ec77|gh2x|kv4x|p4bc|pj41|r83y|tt9q|ur25|wvk6)|pixel[\d ]*a?( pro)?( xl)?( fold)?( \(5g\))?)( bui|\))/i
               ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [
               /(google) (pixelbook( go)?)/i
               ], [VENDOR, MODEL], [

               // Sony
               /droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-\w\w\d\d)(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
               ], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [
               /sony tablet [ps]/i,
               /\b(?:sony)?sgp\w+(?: bui|\))/i
               ], [[MODEL, 'Xperia Tablet'], [VENDOR, SONY], [TYPE, TABLET]], [

               // Amazon
               /(alexa)webm/i,
               /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,                           // Kindle Fire without Silk / Echo Show
               /(kf[a-z]+)( bui|\)).+silk\//i                                      // Kindle Fire HD
               ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [
               /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i                     // Fire Phone
               ], [[MODEL, /(.+)/g, 'Fire Phone $1'], [VENDOR, AMAZON], [TYPE, MOBILE]], [

               // BlackBerry
               /(playbook);[-\w\),; ]+(rim)/i                                      // BlackBerry PlayBook
               ], [MODEL, VENDOR, [TYPE, TABLET]], [
               /\b((?:bb[a-f]|st[hv])100-\d)/i,
               /\(bb10; (\w+)/i                                                    // BlackBerry 10
               ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [

               // Asus
               /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
               ], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [
               / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
               ], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [

               // HTC
               /(nexus 9)/i                                                        // HTC Nexus 9
               ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [
               /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,                         // HTC

               // ZTE
               /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
               /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i         // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
               ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

               // TCL
               /tcl (xess p17aa)/i,
               /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])(_\w(\w|\w\w))?(\)| bui)/i
               ], [MODEL, [VENDOR, 'TCL'], [TYPE, TABLET]], [
               /droid [\w\.]+; (418(?:7d|8v)|5087z|5102l|61(?:02[dh]|25[adfh]|27[ai]|56[dh]|59k|65[ah])|a509dl|t(?:43(?:0w|1[adepqu])|50(?:6d|7[adju])|6(?:09dl|10k|12b|71[efho]|76[hjk])|7(?:66[ahju]|67[hw]|7[045][bh]|71[hk]|73o|76[ho]|79w|81[hks]?|82h|90[bhsy]|99b)|810[hs]))(_\w(\w|\w\w))?(\)| bui)/i
               ], [MODEL, [VENDOR, 'TCL'], [TYPE, MOBILE]], [

               // itel
               /(itel) ((\w+))/i
               ], [[VENDOR, lowerize], MODEL, [TYPE, strMapper, { 'tablet' : ['p10001l', 'w7001'], '*' : 'mobile' }]], [

               // Acer
               /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
               ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [

               // Meizu
               /droid.+; (m[1-5] note) bui/i,
               /\bmz-([-\w]{2,})/i
               ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [
                   
               // Ulefone
               /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
               ], [MODEL, [VENDOR, 'Ulefone'], [TYPE, MOBILE]], [

               // Energizer
               /; (energy ?\w+)(?: bui|\))/i,
               /; energizer ([\w ]+)(?: bui|\))/i
               ], [MODEL, [VENDOR, 'Energizer'], [TYPE, MOBILE]], [

               // Cat
               /; cat (b35);/i,
               /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i
               ], [MODEL, [VENDOR, 'Cat'], [TYPE, MOBILE]], [

               // Smartfren
               /((?:new )?andromax[\w- ]+)(?: bui|\))/i
               ], [MODEL, [VENDOR, 'Smartfren'], [TYPE, MOBILE]], [

               // Nothing
               /droid.+; (a(in)?(0(15|59|6[35])|142)p?)/i
               ], [MODEL, [VENDOR, 'Nothing'], [TYPE, MOBILE]], [

               // Archos
               /; (x67 5g|tikeasy \w+|ac[1789]\d\w+)( b|\))/i,
               /archos ?(5|gamepad2?|([\w ]*[t1789]|hello) ?\d+[\w ]*)( b|\))/i
               ], [MODEL, [VENDOR, 'Archos'], [TYPE, TABLET]], [
               /archos ([\w ]+)( b|\))/i,
               /; (ac[3-6]\d\w{2,8})( b|\))/i 
               ], [MODEL, [VENDOR, 'Archos'], [TYPE, MOBILE]], [

               // HMD
               /; (n159v)/i
               ], [MODEL, [VENDOR, 'HMD'], [TYPE, MOBILE]], [

               // MIXED
               /(imo) (tab \w+)/i,                                                 // IMO
               /(infinix|tecno) (x1101b?|p904|dp(7c|8d|10a)( pro)?|p70[1-3]a?|p904|t1101)/i                     // Infinix XPad / Tecno
               ], [VENDOR, MODEL, [TYPE, TABLET]], [

               /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus(?! zenw)|dell|jolla|meizu|motorola|polytron|tecno|micromax|advan)[-_ ]?([-\w]*)/i,
                                                                                   // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron/Tecno/Micromax/Advan
               /; (blu|hmd|imo|infinix|lava|oneplus|tcl)[_ ]([\w\+ ]+?)(?: bui|\)|; r)/i,  // BLU/HMD/IMO/Infinix/Lava/OnePlus/TCL
               /(hp) ([\w ]+\w)/i,                                                 // HP iPAQ
               /(microsoft); (lumia[\w ]+)/i,                                      // Microsoft Lumia
               /(oppo) ?([\w ]+) bui/i                                             // OPPO
               ], [VENDOR, MODEL, [TYPE, MOBILE]], [

               /(kobo)\s(ereader|touch)/i,                                         // Kobo
               /(hp).+(touchpad(?!.+tablet)|tablet)/i,                             // HP TouchPad
               /(kindle)\/([\w\.]+)/i                                              // Kindle
               ], [VENDOR, MODEL, [TYPE, TABLET]], [

               /(surface duo)/i                                                    // Surface Duo
               ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [
               /droid [\d\.]+; (fp\du?)(?: b|\))/i                                 // Fairphone
               ], [MODEL, [VENDOR, 'Fairphone'], [TYPE, MOBILE]], [
               /((?:tegranote|shield t(?!.+d tv))[\w- ]*?)(?: b|\))/i              // Nvidia Tablets
               ], [MODEL, [VENDOR, NVIDIA], [TYPE, TABLET]], [
               /(sprint) (\w+)/i                                                   // Sprint Phones
               ], [VENDOR, MODEL, [TYPE, MOBILE]], [
               /(kin\.[onetw]{3})/i                                                // Microsoft Kin
               ], [[MODEL, /\./g, ' '], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [
               /droid.+; ([c6]+|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i               // Zebra
               ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [
               /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
               ], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [

               ///////////////////
               // SMARTTVS
               ///////////////////

               /smart-tv.+(samsung)/i                                              // Samsung
               ], [VENDOR, [TYPE, SMARTTV]], [
               /hbbtv.+maple;(\d+)/i
               ], [[MODEL, /^/, 'SmartTV'], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [
               /(vizio)(?: |.+model\/)(\w+-\w+)/i,                                 // Vizio
               /tcast.+(lg)e?. ([-\w]+)/i                                          // LG SmartTV
               ], [VENDOR, MODEL, [TYPE, SMARTTV]], [
               /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
               ], [[VENDOR, LG], [TYPE, SMARTTV]], [
               /(apple) ?tv/i                                                      // Apple TV
               ], [VENDOR, [MODEL, APPLE+' TV'], [TYPE, SMARTTV]], [
               /crkey.*devicetype\/chromecast/i                                    // Google Chromecast Third Generation
               ], [[MODEL, CHROMECAST+' Third Generation'], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [
               /crkey.*devicetype\/([^/]*)/i                                       // Google Chromecast with specific device type
               ], [[MODEL, /^/, 'Chromecast '], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [
               /fuchsia.*crkey/i                                                   // Google Chromecast Nest Hub
               ], [[MODEL, CHROMECAST+' Nest Hub'], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [
               /crkey/i                                                            // Google Chromecast, Linux-based or unknown
               ], [[MODEL, CHROMECAST], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [
               /(portaltv)/i                                                       // Facebook Portal TV
               ], [MODEL, [VENDOR, FACEBOOK], [TYPE, SMARTTV]], [
               /droid.+aft(\w+)( bui|\))/i                                         // Fire TV
               ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [
               /(shield \w+ tv)/i                                                  // Nvidia Shield TV
               ], [MODEL, [VENDOR, NVIDIA], [TYPE, SMARTTV]], [
               /\(dtv[\);].+(aquos)/i,
               /(aquos-tv[\w ]+)\)/i                                               // Sharp
               ], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],[
               /(bravia[\w ]+)( bui|\))/i                                          // Sony
               ], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [
               /(mi(tv|box)-?\w+) bui/i                                            // Xiaomi
               ], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [
               /Hbbtv.*(technisat) (.*);/i                                         // TechniSAT
               ], [VENDOR, MODEL, [TYPE, SMARTTV]], [
               /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,                          // Roku
               /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i         // HbbTV devices
               ], [[VENDOR, /.+\/(\w+)/, '$1', strMapper, {'LG':'lge'}], [MODEL, trim], [TYPE, SMARTTV]], [
                                                                                   // SmartTV from Unidentified Vendors
               /droid.+; ([\w- ]+) (?:android tv|smart[- ]?tv)/i
               ], [MODEL, [TYPE, SMARTTV]], [
               /\b(android tv|smart[- ]?tv|opera tv|tv; rv:|large screen[\w ]+safari)\b/i
               ], [[TYPE, SMARTTV]], [

               ///////////////////
               // CONSOLES
               ///////////////////

               /(playstation \w+)/i                                                // Playstation
               ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [
               /\b(xbox(?: one)?(?!; xbox))[\); ]/i                                // Microsoft Xbox
               ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [
               /(ouya)/i,                                                          // Ouya
               /(nintendo) (\w+)/i,                                                // Nintendo
               /(retroid) (pocket ([^\)]+))/i                                      // Retroid Pocket
               ], [VENDOR, MODEL, [TYPE, CONSOLE]], [
               /droid.+; (shield)( bui|\))/i                                       // Nvidia Portable
               ], [MODEL, [VENDOR, NVIDIA], [TYPE, CONSOLE]], [

               ///////////////////
               // WEARABLES
               ///////////////////

               /\b(sm-[lr]\d\d[0156][fnuw]?s?|gear live)\b/i                       // Samsung Galaxy Watch
               ], [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]], [
               /((pebble))app/i,                                                   // Pebble
               /(asus|google|lg|oppo) ((pixel |zen)?watch[\w ]*)( bui|\))/i        // Asus ZenWatch / LG Watch / Pixel Watch
               ], [VENDOR, MODEL, [TYPE, WEARABLE]], [
               /(ow(?:19|20)?we?[1-3]{1,3})/i                                      // Oppo Watch
               ], [MODEL, [VENDOR, OPPO], [TYPE, WEARABLE]], [
               /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i                              // Apple Watch
               ], [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]], [
               /(opwwe\d{3})/i                                                     // OnePlus Watch
               ], [MODEL, [VENDOR, ONEPLUS], [TYPE, WEARABLE]], [
               /(moto 360)/i                                                       // Motorola 360
               ], [MODEL, [VENDOR, MOTOROLA], [TYPE, WEARABLE]], [
               /(smartwatch 3)/i                                                   // Sony SmartWatch
               ], [MODEL, [VENDOR, SONY], [TYPE, WEARABLE]], [
               /(g watch r)/i                                                      // LG G Watch R
               ], [MODEL, [VENDOR, LG], [TYPE, WEARABLE]], [
               /droid.+; (wt63?0{2,3})\)/i
               ], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [

               ///////////////////
               // XR
               ///////////////////

               /droid.+; (glass) \d/i                                              // Google Glass
               ], [MODEL, [VENDOR, GOOGLE], [TYPE, XR]], [
               /(pico) (4|neo3(?: link|pro)?)/i                                    // Pico
               ], [VENDOR, MODEL, [TYPE, XR]], [
               /(quest( \d| pro)?s?).+vr/i                                         // Meta Quest
               ], [MODEL, [VENDOR, FACEBOOK], [TYPE, XR]], [
               /mobile vr; rv.+firefox/i                                           // Unidentifiable VR device using Firefox Reality / Wolvic
               ], [[TYPE, XR]], [

               ///////////////////
               // EMBEDDED
               ///////////////////

               /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i                              // Tesla
               ], [VENDOR, [TYPE, EMBEDDED]], [
               /(aeobc)\b/i                                                        // Echo Dot
               ], [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]], [
               /(homepod).+mac os/i                                                // Apple HomePod
               ], [MODEL, [VENDOR, APPLE], [TYPE, EMBEDDED]], [
               /windows iot/i                                                      // Unidentifiable embedded device using Windows IoT
               ], [[TYPE, EMBEDDED]], [

               ////////////////////
               // MIXED (GENERIC)
               ///////////////////

               /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+?(mobile|vr|\d) safari/i
               ], [MODEL, [TYPE, strMapper, { 'mobile' : 'Mobile', 'xr' : 'VR', '*' : TABLET }]], [
               /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i                      // Unidentifiable Tablet
               ], [[TYPE, TABLET]], [
               /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i    // Unidentifiable Mobile
               ], [[TYPE, MOBILE]], [
               /droid .+?; ([\w\. -]+)( bui|\))/i                                  // Generic Android Device
               ], [MODEL, [VENDOR, 'Generic']]
           ],

           engine : [[

               /windows.+ edge\/([\w\.]+)/i                                       // EdgeHTML
               ], [VERSION, [NAME, EDGE+'HTML']], [

               /(arkweb)\/([\w\.]+)/i                                              // ArkWeb
               ], [NAME, VERSION], [

               /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i                         // Blink
               ], [VERSION, [NAME, 'Blink']], [

               /(presto)\/([\w\.]+)/i,                                             // Presto
               /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i, // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna/Servo
               /ekioh(flow)\/([\w\.]+)/i,                                          // Flow
               /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,                           // KHTML/Tasman/Links
               /(icab)[\/ ]([23]\.[\d\.]+)/i,                                      // iCab

               /\b(libweb)/i                                                       // LibWeb
               ], [NAME, VERSION], [
               /ladybird\//i
               ], [[NAME, 'LibWeb']], [

               /rv\:([\w\.]{1,9})\b.+(gecko)/i                                     // Gecko
               ], [VERSION, NAME]
           ],

           os : [[

               // Windows
               /(windows nt) (6\.[23]); arm/i                                      // Windows RT
               ], [[NAME, /N/, 'R'], [VERSION, strMapper, windowsVersionMap]], [
               /(windows (?:phone|mobile|iot))(?: os)?[\/ ]?([\d\.]*( se)?)/i,     // Windows IoT/Mobile/Phone
                                                                                   // Windows NT/3.1/95/98/ME/2000/XP/Vista/7/8/8.1/10/11
               /(windows)[\/ ](1[01]|2000|3\.1|7|8(\.1)?|9[58]|me|server 20\d\d( r2)?|vista|xp)/i
               ], [NAME, VERSION], [
               /windows nt ?([\d\.\)]*)(?!.+xbox)/i,
               /\bwin(?=3| ?9|n)(?:nt| 9x )?([\d\.;]*)/i
               ], [[VERSION, /(;|\))/g, '', strMapper, windowsVersionMap], [NAME, WINDOWS]], [
               /(windows ce)\/?([\d\.]*)/i                                         // Windows CE
               ], [NAME, VERSION], [

               // iOS/macOS
               /[adehimnop]{4,7}\b(?:.*os ([\w]+) like mac|; opera)/i,             // iOS
               /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
               /cfnetwork\/.+darwin/i
               ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [
               /(mac os x) ?([\w\. ]*)/i,
               /(macintosh|mac_powerpc\b)(?!.+(haiku|morphos))/i                   // Mac OS
               ], [[NAME, 'macOS'], [VERSION, /_/g, '.']], [

               // Google Chromecast
               /android ([\d\.]+).*crkey/i                                         // Google Chromecast, Android-based
               ], [VERSION, [NAME, CHROMECAST + ' Android']], [
               /fuchsia.*crkey\/([\d\.]+)/i                                        // Google Chromecast, Fuchsia-based
               ], [VERSION, [NAME, CHROMECAST + ' Fuchsia']], [
               /crkey\/([\d\.]+).*devicetype\/smartspeaker/i                       // Google Chromecast, Linux-based Smart Speaker
               ], [VERSION, [NAME, CHROMECAST + ' SmartSpeaker']], [
               /linux.*crkey\/([\d\.]+)/i                                          // Google Chromecast, Legacy Linux-based
               ], [VERSION, [NAME, CHROMECAST + ' Linux']], [
               /crkey\/([\d\.]+)/i                                                 // Google Chromecast, unknown
               ], [VERSION, [NAME, CHROMECAST]], [

               // Mobile OSes
               /droid ([\w\.]+)\b.+(android[- ]x86)/i                              // Android-x86
               ], [VERSION, NAME], [                                               
               /(ubuntu) ([\w\.]+) like android/i                                  // Ubuntu Touch
               ], [[NAME, /(.+)/, '$1 Touch'], VERSION], [
               /(harmonyos)[\/ ]?([\d\.]*)/i,                                      // HarmonyOS
                                                                                   // Android/Blackberry/WebOS/QNX/Bada/RIM/KaiOS/Maemo/MeeGo/S40/Sailfish OS/OpenHarmony/Tizen
               /(android|bada|blackberry|kaios|maemo|meego|openharmony|qnx|rim tablet os|sailfish|series40|symbian|tizen)\w*[-\/\.; ]?([\d\.]*)/i
               ], [NAME, VERSION], [
               /\(bb(10);/i                                                        // BlackBerry 10
               ], [VERSION, [NAME, BLACKBERRY]], [
               /(?:symbian ?os|symbos|s60(?=;)|series ?60)[-\/ ]?([\w\.]*)/i       // Symbian
               ], [VERSION, [NAME, 'Symbian']], [
               /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i // Firefox OS
               ], [VERSION, [NAME, FIREFOX+' OS']], [
               /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i,                             // WebOS
               /webos(?:[ \/]?|\.tv-20(?=2[2-9]))(\d[\d\.]*)/i
               ], [VERSION, [NAME, 'webOS']], [
               /web0s;.+?(?:chr[o0]me|safari)\/(\d+)/i
                                                                                   // https://webostv.developer.lge.com/develop/specifications/web-api-and-web-engine
               ], [[VERSION, strMapper, {'25':'120','24':'108','23':'94','22':'87','6':'79','5':'68','4':'53','3':'38','2':'538','1':'537','*':'TV'}], [NAME, 'webOS']], [                   
               /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i                              // watchOS
               ], [VERSION, [NAME, 'watchOS']], [

               // Google ChromeOS
               /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i                                  // Chromium OS
               ], [[NAME, "Chrome OS"], VERSION],[

               // Smart TVs
               /panasonic;(viera)/i,                                               // Panasonic Viera
               /(netrange)mmh/i,                                                   // Netrange
               /(nettv)\/(\d+\.[\w\.]+)/i,                                         // NetTV

               // Console
               /(nintendo|playstation) (\w+)/i,                                    // Nintendo/Playstation
               /(xbox); +xbox ([^\);]+)/i,                                         // Microsoft Xbox (360, One, X, S, Series X, Series S)
               /(pico) .+os([\w\.]+)/i,                                            // Pico

               // Other
               /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,                            // Joli/Palm
               /linux.+(mint)[\/\(\) ]?([\w\.]*)/i,                                // Mint
               /(mageia|vectorlinux|fuchsia|arcaos|arch(?= ?linux))[;l ]([\d\.]*)/i,  // Mageia/VectorLinux/Fuchsia/ArcaOS/Arch
               /([kxln]?ubuntu|debian|suse|opensuse|gentoo|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire|knoppix)(?: gnu[\/ ]linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                                                                                   // Ubuntu/Debian/SUSE/Gentoo/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire/Knoppix
               /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,                              // Solaris
               /\b(aix)[; ]([1-9\.]{0,4})/i,                                       // AIX
               /(hurd|linux|morphos)(?: (?:arm|x86|ppc)\w*| ?)([\w\.]*)/i,         // Hurd/Linux/MorphOS
               /(gnu) ?([\w\.]*)/i,                                                // GNU
               /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
               /(haiku) ?(r\d)?/i                                                  // Haiku
               ], [NAME, VERSION], [
               /(sunos) ?([\d\.]*)/i                                               // Solaris
               ], [[NAME, 'Solaris'], VERSION], [
               /\b(beos|os\/2|amigaos|openvms|hp-ux|serenityos)/i,                 // BeOS/OS2/AmigaOS/OpenVMS/HP-UX/SerenityOS
               /(unix) ?([\w\.]*)/i                                                // UNIX
               ], [NAME, VERSION]
           ]
       };

       /////////////////
       // Factories
       ////////////////

       var defaultProps = (function () {
               var props = { init : {}, isIgnore : {}, isIgnoreRgx : {}, toString : {}};
               setProps.call(props.init, [
                   [UA_BROWSER, [NAME, VERSION, MAJOR, TYPE]],
                   [UA_CPU, [ARCHITECTURE]],
                   [UA_DEVICE, [TYPE, MODEL, VENDOR]],
                   [UA_ENGINE, [NAME, VERSION]],
                   [UA_OS, [NAME, VERSION]]
               ]);
               setProps.call(props.isIgnore, [
                   [UA_BROWSER, [VERSION, MAJOR]],
                   [UA_ENGINE, [VERSION]],
                   [UA_OS, [VERSION]]
               ]);
               setProps.call(props.isIgnoreRgx, [
                   [UA_BROWSER, / ?browser$/i],
                   [UA_OS, / ?os$/i]
               ]);
               setProps.call(props.toString, [
                   [UA_BROWSER, [NAME, VERSION]],
                   [UA_CPU, [ARCHITECTURE]],
                   [UA_DEVICE, [VENDOR, MODEL]],
                   [UA_ENGINE, [NAME, VERSION]],
                   [UA_OS, [NAME, VERSION]]
               ]);
               return props;
       })();

       var createIData = function (item, itemType) {

           var init_props = defaultProps.init[itemType],
               is_ignoreProps = defaultProps.isIgnore[itemType] || 0,
               is_ignoreRgx = defaultProps.isIgnoreRgx[itemType] || 0,
               toString_props = defaultProps.toString[itemType] || 0;

           function IData () {
               setProps.call(this, init_props);
           }

           IData.prototype.getItem = function () {
               return item;
           };

           IData.prototype.withClientHints = function () {

               // nodejs / non-client-hints browsers
               if (!NAVIGATOR_UADATA) {
                   return item
                           .parseCH()
                           .get();
               }

               // browsers based on chromium 85+
               return NAVIGATOR_UADATA
                       .getHighEntropyValues(CH_ALL_VALUES)
                       .then(function (res) {
                           return item
                                   .setCH(new UACHData(res, false))
                                   .parseCH()
                                   .get();
               });
           };

           IData.prototype.withFeatureCheck = function () {
               return item.detectFeature().get();
           };

           if (itemType != UA_RESULT) {
               IData.prototype.is = function (strToCheck) {
                   var is = false;
                   for (var i in this) {
                       if (this.hasOwnProperty(i) && !has(is_ignoreProps, i) && lowerize(is_ignoreRgx ? strip(is_ignoreRgx, this[i]) : this[i]) == lowerize(is_ignoreRgx ? strip(is_ignoreRgx, strToCheck) : strToCheck)) {
                           is = true;
                           if (strToCheck != UNDEF_TYPE) break;
                       } else if (strToCheck == UNDEF_TYPE && is) {
                           is = !is;
                           break;
                       }
                   }
                   return is;
               };
               IData.prototype.toString = function () {
                   var str = EMPTY;
                   for (var i in toString_props) {
                       if (typeof(this[toString_props[i]]) !== UNDEF_TYPE) {
                           str += (str ? ' ' : EMPTY) + this[toString_props[i]];
                       }
                   }
                   return str || UNDEF_TYPE;
               };
           }

           if (!NAVIGATOR_UADATA) {
               IData.prototype.then = function (cb) { 
                   var that = this;
                   var IDataResolve = function () {
                       for (var prop in that) {
                           if (that.hasOwnProperty(prop)) {
                               this[prop] = that[prop];
                           }
                       }
                   };
                   IDataResolve.prototype = {
                       is : IData.prototype.is,
                       toString : IData.prototype.toString
                   };
                   var resolveData = new IDataResolve();
                   cb(resolveData);
                   return resolveData;
               };
           }

           return new IData();
       };

       /////////////////
       // Constructor
       ////////////////

       function UACHData (uach, isHttpUACH) {
           uach = uach || {};
           setProps.call(this, CH_ALL_VALUES);
           if (isHttpUACH) {
               setProps.call(this, [
                   [BRANDS, itemListToArray(uach[CH_HEADER])],
                   [FULLVERLIST, itemListToArray(uach[CH_HEADER_FULL_VER_LIST])],
                   [MOBILE, /\?1/.test(uach[CH_HEADER_MOBILE])],
                   [MODEL, stripQuotes(uach[CH_HEADER_MODEL])],
                   [PLATFORM, stripQuotes(uach[CH_HEADER_PLATFORM])],
                   [PLATFORMVER, stripQuotes(uach[CH_HEADER_PLATFORM_VER])],
                   [ARCHITECTURE, stripQuotes(uach[CH_HEADER_ARCH])],
                   [FORMFACTORS, itemListToArray(uach[CH_HEADER_FORM_FACTORS])],
                   [BITNESS, stripQuotes(uach[CH_HEADER_BITNESS])]
               ]);
           } else {
               for (var prop in uach) {
                   if(this.hasOwnProperty(prop) && typeof uach[prop] !== UNDEF_TYPE) this[prop] = uach[prop];
               }
           }
       }

       function UAItem (itemType, ua, rgxMap, uaCH) {

           this.get = function (prop) {
               if (!prop) return this.data;
               return this.data.hasOwnProperty(prop) ? this.data[prop] : undefined;
           };

           this.set = function (prop, val) {
               this.data[prop] = val;
               return this;
           };

           this.setCH = function (ch) {
               this.uaCH = ch;
               return this;
           };

           this.detectFeature = function () {
               if (NAVIGATOR && NAVIGATOR.userAgent == this.ua) {
                   switch (this.itemType) {
                       case UA_BROWSER:
                           // Brave-specific detection
                           if (NAVIGATOR.brave && typeof NAVIGATOR.brave.isBrave == FUNC_TYPE) {
                               this.set(NAME, 'Brave');
                           }
                           break;
                       case UA_DEVICE:
                           // Chrome-specific detection: check for 'mobile' value of navigator.userAgentData
                           if (!this.get(TYPE) && NAVIGATOR_UADATA && NAVIGATOR_UADATA[MOBILE]) {
                               this.set(TYPE, MOBILE);
                           }
                           // iPadOS-specific detection: identified as Mac, but has some iOS-only properties
                           if (this.get(MODEL) == 'Macintosh' && NAVIGATOR && typeof NAVIGATOR.standalone !== UNDEF_TYPE && NAVIGATOR.maxTouchPoints && NAVIGATOR.maxTouchPoints > 2) {
                               this.set(MODEL, 'iPad')
                                   .set(TYPE, TABLET);
                           }
                           break;
                       case UA_OS:
                           // Chrome-specific detection: check for 'platform' value of navigator.userAgentData
                           if (!this.get(NAME) && NAVIGATOR_UADATA && NAVIGATOR_UADATA[PLATFORM]) {
                               this.set(NAME, NAVIGATOR_UADATA[PLATFORM]);
                           }
                           break;
                       case UA_RESULT:
                           var data = this.data;
                           var detect = function (itemType) {
                               return data[itemType]
                                       .getItem()
                                       .detectFeature()
                                       .get();
                           };
                           this.set(UA_BROWSER, detect(UA_BROWSER))
                               .set(UA_CPU, detect(UA_CPU))
                               .set(UA_DEVICE, detect(UA_DEVICE))
                               .set(UA_ENGINE, detect(UA_ENGINE))
                               .set(UA_OS, detect(UA_OS));
                   }
               }
               return this;
           };

           this.parseUA = function () {
               if (this.itemType != UA_RESULT) {
                   rgxMapper.call(this.data, this.ua, this.rgxMap);
               }
               if (this.itemType == UA_BROWSER) {
                   this.set(MAJOR, majorize(this.get(VERSION)));
               }
               return this;
           };

           this.parseCH = function () {
               var uaCH = this.uaCH,
                   rgxMap = this.rgxMap;
       
               switch (this.itemType) {
                   case UA_BROWSER:
                   case UA_ENGINE:
                       var brands = uaCH[FULLVERLIST] || uaCH[BRANDS], prevName;
                       if (brands) {
                           for (var i in brands) {
                               var brandName = brands[i].brand || brands[i],
                                   brandVersion = brands[i].version;
                               if (this.itemType == UA_BROWSER && 
                                   !/not.a.brand/i.test(brandName) && 
                                   (!prevName || 
                                       (/Chrom/.test(prevName) && brandName != CHROMIUM) || 
                                       (prevName == EDGE && /WebView2/.test(brandName))
                                   )) {
                                       brandName = strMapper(brandName, browserHintsMap);
                                       prevName = this.get(NAME);
                                       if (!(prevName && !/Chrom/.test(prevName) && /Chrom/.test(brandName))) {
                                           this.set(NAME, brandName)
                                               .set(VERSION, brandVersion)
                                               .set(MAJOR, majorize(brandVersion));
                                       }
                                       prevName = brandName;
                               }
                               if (this.itemType == UA_ENGINE && brandName == CHROMIUM) {
                                   this.set(VERSION, brandVersion);
                               }
                           }
                       }
                       break;
                   case UA_CPU:
                       var archName = uaCH[ARCHITECTURE];
                       if (archName) {
                           if (archName && uaCH[BITNESS] == '64') archName += '64';
                           rgxMapper.call(this.data, archName + ';', rgxMap);
                       }
                       break;
                   case UA_DEVICE:
                       if (uaCH[MOBILE]) {
                           this.set(TYPE, MOBILE);
                       }
                       if (uaCH[MODEL]) {
                           this.set(MODEL, uaCH[MODEL]);
                           if (!this.get(TYPE) || !this.get(VENDOR)) {
                               var reParse = {};
                               rgxMapper.call(reParse, 'droid 9; ' + uaCH[MODEL] + ')', rgxMap);
                               if (!this.get(TYPE) && !!reParse.type) {
                                   this.set(TYPE, reParse.type);
                               }
                               if (!this.get(VENDOR) && !!reParse.vendor) {
                                   this.set(VENDOR, reParse.vendor);
                               }
                           }
                       }
                       if (uaCH[FORMFACTORS]) {
                           var ff;
                           if (typeof uaCH[FORMFACTORS] !== 'string') {
                               var idx = 0;
                               while (!ff && idx < uaCH[FORMFACTORS].length) {
                                   ff = strMapper(uaCH[FORMFACTORS][idx++], formFactorsMap);
                               }
                           } else {
                               ff = strMapper(uaCH[FORMFACTORS], formFactorsMap);
                           }
                           this.set(TYPE, ff);
                       }
                       break;
                   case UA_OS:
                       var osName = uaCH[PLATFORM];
                       if(osName) {
                           var osVersion = uaCH[PLATFORMVER];
                           if (osName == WINDOWS) osVersion = (parseInt(majorize(osVersion), 10) >= 13 ? '11' : '10');
                           this.set(NAME, osName)
                               .set(VERSION, osVersion);
                       }
                       // Xbox-Specific Detection
                       if (this.get(NAME) == WINDOWS && uaCH[MODEL] == 'Xbox') {
                           this.set(NAME, 'Xbox')
                               .set(VERSION, undefined);
                       }           
                       break;
                   case UA_RESULT:
                       var data = this.data;
                       var parse = function (itemType) {
                           return data[itemType]
                                   .getItem()
                                   .setCH(uaCH)
                                   .parseCH()
                                   .get();
                       };
                       this.set(UA_BROWSER, parse(UA_BROWSER))
                           .set(UA_CPU, parse(UA_CPU))
                           .set(UA_DEVICE, parse(UA_DEVICE))
                           .set(UA_ENGINE, parse(UA_ENGINE))
                           .set(UA_OS, parse(UA_OS));
               }
               return this;
           };

           setProps.call(this, [
               ['itemType', itemType],
               ['ua', ua],
               ['uaCH', uaCH],
               ['rgxMap', rgxMap],
               ['data', createIData(this, itemType)]
           ]);

           return this;
       }

       function UAParser (ua, extensions, headers) {

           if (typeof ua === OBJ_TYPE) {
               if (isExtensions(ua, true)) {
                   if (typeof extensions === OBJ_TYPE) {
                       headers = extensions;               // case UAParser(extensions, headers)           
                   }
                   extensions = ua;                        // case UAParser(extensions)
               } else {
                   headers = ua;                           // case UAParser(headers)
                   extensions = undefined;
               }
               ua = undefined;
           } else if (typeof ua === STR_TYPE && !isExtensions(extensions, true)) {
               headers = extensions;                       // case UAParser(ua, headers)
               extensions = undefined;
           }

           // Convert Headers object into a plain object
           if (headers && typeof headers.append === FUNC_TYPE) {
               var kv = {};
               headers.forEach(function (v, k) { kv[k] = v; });
               headers = kv;
           }
           
           if (!(this instanceof UAParser)) {
               return new UAParser(ua, extensions, headers).getResult();
           }

           var userAgent = typeof ua === STR_TYPE ? ua :                                       // Passed user-agent string
                                   (headers && headers[USER_AGENT] ? headers[USER_AGENT] :     // User-Agent from passed headers
                                   ((NAVIGATOR && NAVIGATOR.userAgent) ? NAVIGATOR.userAgent : // navigator.userAgent
                                       EMPTY)),                                                // empty string

               httpUACH = new UACHData(headers, true),
               regexMap = extensions ? 
                           extend(defaultRegexes, extensions) : 
                           defaultRegexes,

               createItemFunc = function (itemType) {
                   if (itemType == UA_RESULT) {
                       return function () {
                           return new UAItem(itemType, userAgent, regexMap, httpUACH)
                                       .set('ua', userAgent)
                                       .set(UA_BROWSER, this.getBrowser())
                                       .set(UA_CPU, this.getCPU())
                                       .set(UA_DEVICE, this.getDevice())
                                       .set(UA_ENGINE, this.getEngine())
                                       .set(UA_OS, this.getOS())
                                       .get();
                       };
                   } else {
                       return function () {
                           return new UAItem(itemType, userAgent, regexMap[itemType], httpUACH)
                                       .parseUA()
                                       .get();
                       };
                   }
               };
               
           // public methods
           setProps.call(this, [
               ['getBrowser', createItemFunc(UA_BROWSER)],
               ['getCPU', createItemFunc(UA_CPU)],
               ['getDevice', createItemFunc(UA_DEVICE)],
               ['getEngine', createItemFunc(UA_ENGINE)],
               ['getOS', createItemFunc(UA_OS)],
               ['getResult', createItemFunc(UA_RESULT)],
               ['getUA', function () { return userAgent; }],
               ['setUA', function (ua) {
                   if (isString(ua))
                       userAgent = ua.length > UA_MAX_LENGTH ? trim(ua, UA_MAX_LENGTH) : ua;
                   return this;
               }]
           ])
           .setUA(userAgent);

           return this;
       }

       UAParser.VERSION = LIBVERSION;
       UAParser.BROWSER =  enumerize([NAME, VERSION, MAJOR, TYPE]);
       UAParser.CPU = enumerize([ARCHITECTURE]);
       UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
       UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);

   function getDefaultExportFromCjs (x) {
   	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
   }

   var jws = {};

   var safeBuffer = {exports: {}};

   /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

   var hasRequiredSafeBuffer;

   function requireSafeBuffer () {
   	if (hasRequiredSafeBuffer) return safeBuffer.exports;
   	hasRequiredSafeBuffer = 1;
   	(function (module, exports) {
   		/* eslint-disable node/no-deprecated-api */
   		var buffer = require$$0;
   		var Buffer = buffer.Buffer;

   		// alternative to using Object.keys for old browsers
   		function copyProps (src, dst) {
   		  for (var key in src) {
   		    dst[key] = src[key];
   		  }
   		}
   		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
   		  module.exports = buffer;
   		} else {
   		  // Copy properties from require('buffer')
   		  copyProps(buffer, exports);
   		  exports.Buffer = SafeBuffer;
   		}

   		function SafeBuffer (arg, encodingOrOffset, length) {
   		  return Buffer(arg, encodingOrOffset, length)
   		}

   		SafeBuffer.prototype = Object.create(Buffer.prototype);

   		// Copy static methods from Buffer
   		copyProps(Buffer, SafeBuffer);

   		SafeBuffer.from = function (arg, encodingOrOffset, length) {
   		  if (typeof arg === 'number') {
   		    throw new TypeError('Argument must not be a number')
   		  }
   		  return Buffer(arg, encodingOrOffset, length)
   		};

   		SafeBuffer.alloc = function (size, fill, encoding) {
   		  if (typeof size !== 'number') {
   		    throw new TypeError('Argument must be a number')
   		  }
   		  var buf = Buffer(size);
   		  if (fill !== undefined) {
   		    if (typeof encoding === 'string') {
   		      buf.fill(fill, encoding);
   		    } else {
   		      buf.fill(fill);
   		    }
   		  } else {
   		    buf.fill(0);
   		  }
   		  return buf
   		};

   		SafeBuffer.allocUnsafe = function (size) {
   		  if (typeof size !== 'number') {
   		    throw new TypeError('Argument must be a number')
   		  }
   		  return Buffer(size)
   		};

   		SafeBuffer.allocUnsafeSlow = function (size) {
   		  if (typeof size !== 'number') {
   		    throw new TypeError('Argument must be a number')
   		  }
   		  return buffer.SlowBuffer(size)
   		}; 
   	} (safeBuffer, safeBuffer.exports));
   	return safeBuffer.exports;
   }

   /*global module, process*/

   var dataStream;
   var hasRequiredDataStream;

   function requireDataStream () {
   	if (hasRequiredDataStream) return dataStream;
   	hasRequiredDataStream = 1;
   	var Buffer = requireSafeBuffer().Buffer;
   	var Stream = require$$3;
   	var util = require$$5;

   	function DataStream(data) {
   	  this.buffer = null;
   	  this.writable = true;
   	  this.readable = true;

   	  // No input
   	  if (!data) {
   	    this.buffer = Buffer.alloc(0);
   	    return this;
   	  }

   	  // Stream
   	  if (typeof data.pipe === 'function') {
   	    this.buffer = Buffer.alloc(0);
   	    data.pipe(this);
   	    return this;
   	  }

   	  // Buffer or String
   	  // or Object (assumedly a passworded key)
   	  if (data.length || typeof data === 'object') {
   	    this.buffer = data;
   	    this.writable = false;
   	    process.nextTick(function () {
   	      this.emit('end', data);
   	      this.readable = false;
   	      this.emit('close');
   	    }.bind(this));
   	    return this;
   	  }

   	  throw new TypeError('Unexpected data type ('+ typeof data + ')');
   	}
   	util.inherits(DataStream, Stream);

   	DataStream.prototype.write = function write(data) {
   	  this.buffer = Buffer.concat([this.buffer, Buffer.from(data)]);
   	  this.emit('data', data);
   	};

   	DataStream.prototype.end = function end(data) {
   	  if (data)
   	    this.write(data);
   	  this.emit('end', data);
   	  this.emit('close');
   	  this.writable = false;
   	  this.readable = false;
   	};

   	dataStream = DataStream;
   	return dataStream;
   }

   var paramBytesForAlg_1;
   var hasRequiredParamBytesForAlg;

   function requireParamBytesForAlg () {
   	if (hasRequiredParamBytesForAlg) return paramBytesForAlg_1;
   	hasRequiredParamBytesForAlg = 1;

   	function getParamSize(keySize) {
   		var result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);
   		return result;
   	}

   	var paramBytesForAlg = {
   		ES256: getParamSize(256),
   		ES384: getParamSize(384),
   		ES512: getParamSize(521)
   	};

   	function getParamBytesForAlg(alg) {
   		var paramBytes = paramBytesForAlg[alg];
   		if (paramBytes) {
   			return paramBytes;
   		}

   		throw new Error('Unknown algorithm "' + alg + '"');
   	}

   	paramBytesForAlg_1 = getParamBytesForAlg;
   	return paramBytesForAlg_1;
   }

   var ecdsaSigFormatter;
   var hasRequiredEcdsaSigFormatter;

   function requireEcdsaSigFormatter () {
   	if (hasRequiredEcdsaSigFormatter) return ecdsaSigFormatter;
   	hasRequiredEcdsaSigFormatter = 1;

   	var Buffer = requireSafeBuffer().Buffer;

   	var getParamBytesForAlg = requireParamBytesForAlg();

   	var MAX_OCTET = 0x80,
   		CLASS_UNIVERSAL = 0,
   		PRIMITIVE_BIT = 0x20,
   		TAG_SEQ = 0x10,
   		TAG_INT = 0x02,
   		ENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6),
   		ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);

   	function base64Url(base64) {
   		return base64
   			.replace(/=/g, '')
   			.replace(/\+/g, '-')
   			.replace(/\//g, '_');
   	}

   	function signatureAsBuffer(signature) {
   		if (Buffer.isBuffer(signature)) {
   			return signature;
   		} else if ('string' === typeof signature) {
   			return Buffer.from(signature, 'base64');
   		}

   		throw new TypeError('ECDSA signature must be a Base64 string or a Buffer');
   	}

   	function derToJose(signature, alg) {
   		signature = signatureAsBuffer(signature);
   		var paramBytes = getParamBytesForAlg(alg);

   		// the DER encoded param should at most be the param size, plus a padding
   		// zero, since due to being a signed integer
   		var maxEncodedParamLength = paramBytes + 1;

   		var inputLength = signature.length;

   		var offset = 0;
   		if (signature[offset++] !== ENCODED_TAG_SEQ) {
   			throw new Error('Could not find expected "seq"');
   		}

   		var seqLength = signature[offset++];
   		if (seqLength === (MAX_OCTET | 1)) {
   			seqLength = signature[offset++];
   		}

   		if (inputLength - offset < seqLength) {
   			throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
   		}

   		if (signature[offset++] !== ENCODED_TAG_INT) {
   			throw new Error('Could not find expected "int" for "r"');
   		}

   		var rLength = signature[offset++];

   		if (inputLength - offset - 2 < rLength) {
   			throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
   		}

   		if (maxEncodedParamLength < rLength) {
   			throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
   		}

   		var rOffset = offset;
   		offset += rLength;

   		if (signature[offset++] !== ENCODED_TAG_INT) {
   			throw new Error('Could not find expected "int" for "s"');
   		}

   		var sLength = signature[offset++];

   		if (inputLength - offset !== sLength) {
   			throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
   		}

   		if (maxEncodedParamLength < sLength) {
   			throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
   		}

   		var sOffset = offset;
   		offset += sLength;

   		if (offset !== inputLength) {
   			throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
   		}

   		var rPadding = paramBytes - rLength,
   			sPadding = paramBytes - sLength;

   		var dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);

   		for (offset = 0; offset < rPadding; ++offset) {
   			dst[offset] = 0;
   		}
   		signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);

   		offset = paramBytes;

   		for (var o = offset; offset < o + sPadding; ++offset) {
   			dst[offset] = 0;
   		}
   		signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);

   		dst = dst.toString('base64');
   		dst = base64Url(dst);

   		return dst;
   	}

   	function countPadding(buf, start, stop) {
   		var padding = 0;
   		while (start + padding < stop && buf[start + padding] === 0) {
   			++padding;
   		}

   		var needsSign = buf[start + padding] >= MAX_OCTET;
   		if (needsSign) {
   			--padding;
   		}

   		return padding;
   	}

   	function joseToDer(signature, alg) {
   		signature = signatureAsBuffer(signature);
   		var paramBytes = getParamBytesForAlg(alg);

   		var signatureBytes = signature.length;
   		if (signatureBytes !== paramBytes * 2) {
   			throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
   		}

   		var rPadding = countPadding(signature, 0, paramBytes);
   		var sPadding = countPadding(signature, paramBytes, signature.length);
   		var rLength = paramBytes - rPadding;
   		var sLength = paramBytes - sPadding;

   		var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;

   		var shortLength = rsBytes < MAX_OCTET;

   		var dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);

   		var offset = 0;
   		dst[offset++] = ENCODED_TAG_SEQ;
   		if (shortLength) {
   			// Bit 8 has value "0"
   			// bits 7-1 give the length.
   			dst[offset++] = rsBytes;
   		} else {
   			// Bit 8 of first octet has value "1"
   			// bits 7-1 give the number of additional length octets.
   			dst[offset++] = MAX_OCTET	| 1;
   			// length, base 256
   			dst[offset++] = rsBytes & 0xff;
   		}
   		dst[offset++] = ENCODED_TAG_INT;
   		dst[offset++] = rLength;
   		if (rPadding < 0) {
   			dst[offset++] = 0;
   			offset += signature.copy(dst, offset, 0, paramBytes);
   		} else {
   			offset += signature.copy(dst, offset, rPadding, paramBytes);
   		}
   		dst[offset++] = ENCODED_TAG_INT;
   		dst[offset++] = sLength;
   		if (sPadding < 0) {
   			dst[offset++] = 0;
   			signature.copy(dst, offset, paramBytes);
   		} else {
   			signature.copy(dst, offset, paramBytes + sPadding);
   		}

   		return dst;
   	}

   	ecdsaSigFormatter = {
   		derToJose: derToJose,
   		joseToDer: joseToDer
   	};
   	return ecdsaSigFormatter;
   }

   /*jshint node:true */

   var bufferEqualConstantTime;
   var hasRequiredBufferEqualConstantTime;

   function requireBufferEqualConstantTime () {
   	if (hasRequiredBufferEqualConstantTime) return bufferEqualConstantTime;
   	hasRequiredBufferEqualConstantTime = 1;
   	var Buffer = require$$0.Buffer; // browserify
   	var SlowBuffer = require$$0.SlowBuffer;

   	bufferEqualConstantTime = bufferEq;

   	function bufferEq(a, b) {

   	  // shortcutting on type is necessary for correctness
   	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
   	    return false;
   	  }

   	  // buffer sizes should be well-known information, so despite this
   	  // shortcutting, it doesn't leak any information about the *contents* of the
   	  // buffers.
   	  if (a.length !== b.length) {
   	    return false;
   	  }

   	  var c = 0;
   	  for (var i = 0; i < a.length; i++) {
   	    /*jshint bitwise:false */
   	    c |= a[i] ^ b[i]; // XOR
   	  }
   	  return c === 0;
   	}

   	bufferEq.install = function() {
   	  Buffer.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
   	    return bufferEq(this, that);
   	  };
   	};

   	var origBufEqual = Buffer.prototype.equal;
   	var origSlowBufEqual = SlowBuffer.prototype.equal;
   	bufferEq.restore = function() {
   	  Buffer.prototype.equal = origBufEqual;
   	  SlowBuffer.prototype.equal = origSlowBufEqual;
   	};
   	return bufferEqualConstantTime;
   }

   var jwa;
   var hasRequiredJwa;

   function requireJwa () {
   	if (hasRequiredJwa) return jwa;
   	hasRequiredJwa = 1;
   	var Buffer = requireSafeBuffer().Buffer;
   	var crypto = require$$1;
   	var formatEcdsa = requireEcdsaSigFormatter();
   	var util = require$$5;

   	var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
   	var MSG_INVALID_SECRET = 'secret must be a string or buffer';
   	var MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';
   	var MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';

   	var supportsKeyObjects = typeof crypto.createPublicKey === 'function';
   	if (supportsKeyObjects) {
   	  MSG_INVALID_VERIFIER_KEY += ' or a KeyObject';
   	  MSG_INVALID_SECRET += 'or a KeyObject';
   	}

   	function checkIsPublicKey(key) {
   	  if (Buffer.isBuffer(key)) {
   	    return;
   	  }

   	  if (typeof key === 'string') {
   	    return;
   	  }

   	  if (!supportsKeyObjects) {
   	    throw typeError(MSG_INVALID_VERIFIER_KEY);
   	  }

   	  if (typeof key !== 'object') {
   	    throw typeError(MSG_INVALID_VERIFIER_KEY);
   	  }

   	  if (typeof key.type !== 'string') {
   	    throw typeError(MSG_INVALID_VERIFIER_KEY);
   	  }

   	  if (typeof key.asymmetricKeyType !== 'string') {
   	    throw typeError(MSG_INVALID_VERIFIER_KEY);
   	  }

   	  if (typeof key.export !== 'function') {
   	    throw typeError(MSG_INVALID_VERIFIER_KEY);
   	  }
   	}
   	function checkIsPrivateKey(key) {
   	  if (Buffer.isBuffer(key)) {
   	    return;
   	  }

   	  if (typeof key === 'string') {
   	    return;
   	  }

   	  if (typeof key === 'object') {
   	    return;
   	  }

   	  throw typeError(MSG_INVALID_SIGNER_KEY);
   	}
   	function checkIsSecretKey(key) {
   	  if (Buffer.isBuffer(key)) {
   	    return;
   	  }

   	  if (typeof key === 'string') {
   	    return key;
   	  }

   	  if (!supportsKeyObjects) {
   	    throw typeError(MSG_INVALID_SECRET);
   	  }

   	  if (typeof key !== 'object') {
   	    throw typeError(MSG_INVALID_SECRET);
   	  }

   	  if (key.type !== 'secret') {
   	    throw typeError(MSG_INVALID_SECRET);
   	  }

   	  if (typeof key.export !== 'function') {
   	    throw typeError(MSG_INVALID_SECRET);
   	  }
   	}

   	function fromBase64(base64) {
   	  return base64
   	    .replace(/=/g, '')
   	    .replace(/\+/g, '-')
   	    .replace(/\//g, '_');
   	}

   	function toBase64(base64url) {
   	  base64url = base64url.toString();

   	  var padding = 4 - base64url.length % 4;
   	  if (padding !== 4) {
   	    for (var i = 0; i < padding; ++i) {
   	      base64url += '=';
   	    }
   	  }

   	  return base64url
   	    .replace(/\-/g, '+')
   	    .replace(/_/g, '/');
   	}

   	function typeError(template) {
   	  var args = [].slice.call(arguments, 1);
   	  var errMsg = util.format.bind(util, template).apply(null, args);
   	  return new TypeError(errMsg);
   	}

   	function bufferOrString(obj) {
   	  return Buffer.isBuffer(obj) || typeof obj === 'string';
   	}

   	function normalizeInput(thing) {
   	  if (!bufferOrString(thing))
   	    thing = JSON.stringify(thing);
   	  return thing;
   	}

   	function createHmacSigner(bits) {
   	  return function sign(thing, secret) {
   	    checkIsSecretKey(secret);
   	    thing = normalizeInput(thing);
   	    var hmac = crypto.createHmac('sha' + bits, secret);
   	    var sig = (hmac.update(thing), hmac.digest('base64'));
   	    return fromBase64(sig);
   	  }
   	}

   	var bufferEqual;
   	var timingSafeEqual = 'timingSafeEqual' in crypto ? function timingSafeEqual(a, b) {
   	  if (a.byteLength !== b.byteLength) {
   	    return false;
   	  }

   	  return crypto.timingSafeEqual(a, b)
   	} : function timingSafeEqual(a, b) {
   	  if (!bufferEqual) {
   	    bufferEqual = requireBufferEqualConstantTime();
   	  }

   	  return bufferEqual(a, b)
   	};

   	function createHmacVerifier(bits) {
   	  return function verify(thing, signature, secret) {
   	    var computedSig = createHmacSigner(bits)(thing, secret);
   	    return timingSafeEqual(Buffer.from(signature), Buffer.from(computedSig));
   	  }
   	}

   	function createKeySigner(bits) {
   	 return function sign(thing, privateKey) {
   	    checkIsPrivateKey(privateKey);
   	    thing = normalizeInput(thing);
   	    // Even though we are specifying "RSA" here, this works with ECDSA
   	    // keys as well.
   	    var signer = crypto.createSign('RSA-SHA' + bits);
   	    var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));
   	    return fromBase64(sig);
   	  }
   	}

   	function createKeyVerifier(bits) {
   	  return function verify(thing, signature, publicKey) {
   	    checkIsPublicKey(publicKey);
   	    thing = normalizeInput(thing);
   	    signature = toBase64(signature);
   	    var verifier = crypto.createVerify('RSA-SHA' + bits);
   	    verifier.update(thing);
   	    return verifier.verify(publicKey, signature, 'base64');
   	  }
   	}

   	function createPSSKeySigner(bits) {
   	  return function sign(thing, privateKey) {
   	    checkIsPrivateKey(privateKey);
   	    thing = normalizeInput(thing);
   	    var signer = crypto.createSign('RSA-SHA' + bits);
   	    var sig = (signer.update(thing), signer.sign({
   	      key: privateKey,
   	      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
   	      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
   	    }, 'base64'));
   	    return fromBase64(sig);
   	  }
   	}

   	function createPSSKeyVerifier(bits) {
   	  return function verify(thing, signature, publicKey) {
   	    checkIsPublicKey(publicKey);
   	    thing = normalizeInput(thing);
   	    signature = toBase64(signature);
   	    var verifier = crypto.createVerify('RSA-SHA' + bits);
   	    verifier.update(thing);
   	    return verifier.verify({
   	      key: publicKey,
   	      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
   	      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
   	    }, signature, 'base64');
   	  }
   	}

   	function createECDSASigner(bits) {
   	  var inner = createKeySigner(bits);
   	  return function sign() {
   	    var signature = inner.apply(null, arguments);
   	    signature = formatEcdsa.derToJose(signature, 'ES' + bits);
   	    return signature;
   	  };
   	}

   	function createECDSAVerifer(bits) {
   	  var inner = createKeyVerifier(bits);
   	  return function verify(thing, signature, publicKey) {
   	    signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');
   	    var result = inner(thing, signature, publicKey);
   	    return result;
   	  };
   	}

   	function createNoneSigner() {
   	  return function sign() {
   	    return '';
   	  }
   	}

   	function createNoneVerifier() {
   	  return function verify(thing, signature) {
   	    return signature === '';
   	  }
   	}

   	jwa = function jwa(algorithm) {
   	  var signerFactories = {
   	    hs: createHmacSigner,
   	    rs: createKeySigner,
   	    ps: createPSSKeySigner,
   	    es: createECDSASigner,
   	    none: createNoneSigner,
   	  };
   	  var verifierFactories = {
   	    hs: createHmacVerifier,
   	    rs: createKeyVerifier,
   	    ps: createPSSKeyVerifier,
   	    es: createECDSAVerifer,
   	    none: createNoneVerifier,
   	  };
   	  var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
   	  if (!match)
   	    throw typeError(MSG_INVALID_ALGORITHM, algorithm);
   	  var algo = (match[1] || match[3]).toLowerCase();
   	  var bits = match[2];

   	  return {
   	    sign: signerFactories[algo](bits),
   	    verify: verifierFactories[algo](bits),
   	  }
   	};
   	return jwa;
   }

   /*global module*/

   var tostring;
   var hasRequiredTostring;

   function requireTostring () {
   	if (hasRequiredTostring) return tostring;
   	hasRequiredTostring = 1;
   	var Buffer = require$$0.Buffer;

   	tostring = function toString(obj) {
   	  if (typeof obj === 'string')
   	    return obj;
   	  if (typeof obj === 'number' || Buffer.isBuffer(obj))
   	    return obj.toString();
   	  return JSON.stringify(obj);
   	};
   	return tostring;
   }

   /*global module*/

   var signStream;
   var hasRequiredSignStream;

   function requireSignStream () {
   	if (hasRequiredSignStream) return signStream;
   	hasRequiredSignStream = 1;
   	var Buffer = requireSafeBuffer().Buffer;
   	var DataStream = requireDataStream();
   	var jwa = requireJwa();
   	var Stream = require$$3;
   	var toString = requireTostring();
   	var util = require$$5;

   	function base64url(string, encoding) {
   	  return Buffer
   	    .from(string, encoding)
   	    .toString('base64')
   	    .replace(/=/g, '')
   	    .replace(/\+/g, '-')
   	    .replace(/\//g, '_');
   	}

   	function jwsSecuredInput(header, payload, encoding) {
   	  encoding = encoding || 'utf8';
   	  var encodedHeader = base64url(toString(header), 'binary');
   	  var encodedPayload = base64url(toString(payload), encoding);
   	  return util.format('%s.%s', encodedHeader, encodedPayload);
   	}

   	function jwsSign(opts) {
   	  var header = opts.header;
   	  var payload = opts.payload;
   	  var secretOrKey = opts.secret || opts.privateKey;
   	  var encoding = opts.encoding;
   	  var algo = jwa(header.alg);
   	  var securedInput = jwsSecuredInput(header, payload, encoding);
   	  var signature = algo.sign(securedInput, secretOrKey);
   	  return util.format('%s.%s', securedInput, signature);
   	}

   	function SignStream(opts) {
   	  var secret = opts.secret||opts.privateKey||opts.key;
   	  var secretStream = new DataStream(secret);
   	  this.readable = true;
   	  this.header = opts.header;
   	  this.encoding = opts.encoding;
   	  this.secret = this.privateKey = this.key = secretStream;
   	  this.payload = new DataStream(opts.payload);
   	  this.secret.once('close', function () {
   	    if (!this.payload.writable && this.readable)
   	      this.sign();
   	  }.bind(this));

   	  this.payload.once('close', function () {
   	    if (!this.secret.writable && this.readable)
   	      this.sign();
   	  }.bind(this));
   	}
   	util.inherits(SignStream, Stream);

   	SignStream.prototype.sign = function sign() {
   	  try {
   	    var signature = jwsSign({
   	      header: this.header,
   	      payload: this.payload.buffer,
   	      secret: this.secret.buffer,
   	      encoding: this.encoding
   	    });
   	    this.emit('done', signature);
   	    this.emit('data', signature);
   	    this.emit('end');
   	    this.readable = false;
   	    return signature;
   	  } catch (e) {
   	    this.readable = false;
   	    this.emit('error', e);
   	    this.emit('close');
   	  }
   	};

   	SignStream.sign = jwsSign;

   	signStream = SignStream;
   	return signStream;
   }

   /*global module*/

   var verifyStream;
   var hasRequiredVerifyStream;

   function requireVerifyStream () {
   	if (hasRequiredVerifyStream) return verifyStream;
   	hasRequiredVerifyStream = 1;
   	var Buffer = requireSafeBuffer().Buffer;
   	var DataStream = requireDataStream();
   	var jwa = requireJwa();
   	var Stream = require$$3;
   	var toString = requireTostring();
   	var util = require$$5;
   	var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;

   	function isObject(thing) {
   	  return Object.prototype.toString.call(thing) === '[object Object]';
   	}

   	function safeJsonParse(thing) {
   	  if (isObject(thing))
   	    return thing;
   	  try { return JSON.parse(thing); }
   	  catch (e) { return undefined; }
   	}

   	function headerFromJWS(jwsSig) {
   	  var encodedHeader = jwsSig.split('.', 1)[0];
   	  return safeJsonParse(Buffer.from(encodedHeader, 'base64').toString('binary'));
   	}

   	function securedInputFromJWS(jwsSig) {
   	  return jwsSig.split('.', 2).join('.');
   	}

   	function signatureFromJWS(jwsSig) {
   	  return jwsSig.split('.')[2];
   	}

   	function payloadFromJWS(jwsSig, encoding) {
   	  encoding = encoding || 'utf8';
   	  var payload = jwsSig.split('.')[1];
   	  return Buffer.from(payload, 'base64').toString(encoding);
   	}

   	function isValidJws(string) {
   	  return JWS_REGEX.test(string) && !!headerFromJWS(string);
   	}

   	function jwsVerify(jwsSig, algorithm, secretOrKey) {
   	  if (!algorithm) {
   	    var err = new Error("Missing algorithm parameter for jws.verify");
   	    err.code = "MISSING_ALGORITHM";
   	    throw err;
   	  }
   	  jwsSig = toString(jwsSig);
   	  var signature = signatureFromJWS(jwsSig);
   	  var securedInput = securedInputFromJWS(jwsSig);
   	  var algo = jwa(algorithm);
   	  return algo.verify(securedInput, signature, secretOrKey);
   	}

   	function jwsDecode(jwsSig, opts) {
   	  opts = opts || {};
   	  jwsSig = toString(jwsSig);

   	  if (!isValidJws(jwsSig))
   	    return null;

   	  var header = headerFromJWS(jwsSig);

   	  if (!header)
   	    return null;

   	  var payload = payloadFromJWS(jwsSig);
   	  if (header.typ === 'JWT' || opts.json)
   	    payload = JSON.parse(payload, opts.encoding);

   	  return {
   	    header: header,
   	    payload: payload,
   	    signature: signatureFromJWS(jwsSig)
   	  };
   	}

   	function VerifyStream(opts) {
   	  opts = opts || {};
   	  var secretOrKey = opts.secret||opts.publicKey||opts.key;
   	  var secretStream = new DataStream(secretOrKey);
   	  this.readable = true;
   	  this.algorithm = opts.algorithm;
   	  this.encoding = opts.encoding;
   	  this.secret = this.publicKey = this.key = secretStream;
   	  this.signature = new DataStream(opts.signature);
   	  this.secret.once('close', function () {
   	    if (!this.signature.writable && this.readable)
   	      this.verify();
   	  }.bind(this));

   	  this.signature.once('close', function () {
   	    if (!this.secret.writable && this.readable)
   	      this.verify();
   	  }.bind(this));
   	}
   	util.inherits(VerifyStream, Stream);
   	VerifyStream.prototype.verify = function verify() {
   	  try {
   	    var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
   	    var obj = jwsDecode(this.signature.buffer, this.encoding);
   	    this.emit('done', valid, obj);
   	    this.emit('data', valid);
   	    this.emit('end');
   	    this.readable = false;
   	    return valid;
   	  } catch (e) {
   	    this.readable = false;
   	    this.emit('error', e);
   	    this.emit('close');
   	  }
   	};

   	VerifyStream.decode = jwsDecode;
   	VerifyStream.isValid = isValidJws;
   	VerifyStream.verify = jwsVerify;

   	verifyStream = VerifyStream;
   	return verifyStream;
   }

   /*global exports*/

   var hasRequiredJws;

   function requireJws () {
   	if (hasRequiredJws) return jws;
   	hasRequiredJws = 1;
   	var SignStream = requireSignStream();
   	var VerifyStream = requireVerifyStream();

   	var ALGORITHMS = [
   	  'HS256', 'HS384', 'HS512',
   	  'RS256', 'RS384', 'RS512',
   	  'PS256', 'PS384', 'PS512',
   	  'ES256', 'ES384', 'ES512'
   	];

   	jws.ALGORITHMS = ALGORITHMS;
   	jws.sign = SignStream.sign;
   	jws.verify = VerifyStream.verify;
   	jws.decode = VerifyStream.decode;
   	jws.isValid = VerifyStream.isValid;
   	jws.createSign = function createSign(opts) {
   	  return new SignStream(opts);
   	};
   	jws.createVerify = function createVerify(opts) {
   	  return new VerifyStream(opts);
   	};
   	return jws;
   }

   var decode;
   var hasRequiredDecode;

   function requireDecode () {
   	if (hasRequiredDecode) return decode;
   	hasRequiredDecode = 1;
   	var jws = requireJws();

   	decode = function (jwt, options) {
   	  options = options || {};
   	  var decoded = jws.decode(jwt, options);
   	  if (!decoded) { return null; }
   	  var payload = decoded.payload;

   	  //try parse the payload
   	  if(typeof payload === 'string') {
   	    try {
   	      var obj = JSON.parse(payload);
   	      if(obj !== null && typeof obj === 'object') {
   	        payload = obj;
   	      }
   	    } catch (e) { }
   	  }

   	  //return header if `complete` option is enabled.  header includes claims
   	  //such as `kid` and `alg` used to select the key within a JWKS needed to
   	  //verify the signature
   	  if (options.complete === true) {
   	    return {
   	      header: decoded.header,
   	      payload: payload,
   	      signature: decoded.signature
   	    };
   	  }
   	  return payload;
   	};
   	return decode;
   }

   var JsonWebTokenError_1;
   var hasRequiredJsonWebTokenError;

   function requireJsonWebTokenError () {
   	if (hasRequiredJsonWebTokenError) return JsonWebTokenError_1;
   	hasRequiredJsonWebTokenError = 1;
   	var JsonWebTokenError = function (message, error) {
   	  Error.call(this, message);
   	  if(Error.captureStackTrace) {
   	    Error.captureStackTrace(this, this.constructor);
   	  }
   	  this.name = 'JsonWebTokenError';
   	  this.message = message;
   	  if (error) this.inner = error;
   	};

   	JsonWebTokenError.prototype = Object.create(Error.prototype);
   	JsonWebTokenError.prototype.constructor = JsonWebTokenError;

   	JsonWebTokenError_1 = JsonWebTokenError;
   	return JsonWebTokenError_1;
   }

   var NotBeforeError_1;
   var hasRequiredNotBeforeError;

   function requireNotBeforeError () {
   	if (hasRequiredNotBeforeError) return NotBeforeError_1;
   	hasRequiredNotBeforeError = 1;
   	var JsonWebTokenError = requireJsonWebTokenError();

   	var NotBeforeError = function (message, date) {
   	  JsonWebTokenError.call(this, message);
   	  this.name = 'NotBeforeError';
   	  this.date = date;
   	};

   	NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);

   	NotBeforeError.prototype.constructor = NotBeforeError;

   	NotBeforeError_1 = NotBeforeError;
   	return NotBeforeError_1;
   }

   var TokenExpiredError_1;
   var hasRequiredTokenExpiredError;

   function requireTokenExpiredError () {
   	if (hasRequiredTokenExpiredError) return TokenExpiredError_1;
   	hasRequiredTokenExpiredError = 1;
   	var JsonWebTokenError = requireJsonWebTokenError();

   	var TokenExpiredError = function (message, expiredAt) {
   	  JsonWebTokenError.call(this, message);
   	  this.name = 'TokenExpiredError';
   	  this.expiredAt = expiredAt;
   	};

   	TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);

   	TokenExpiredError.prototype.constructor = TokenExpiredError;

   	TokenExpiredError_1 = TokenExpiredError;
   	return TokenExpiredError_1;
   }

   /**
    * Helpers.
    */

   var ms;
   var hasRequiredMs;

   function requireMs () {
   	if (hasRequiredMs) return ms;
   	hasRequiredMs = 1;
   	var s = 1000;
   	var m = s * 60;
   	var h = m * 60;
   	var d = h * 24;
   	var w = d * 7;
   	var y = d * 365.25;

   	/**
   	 * Parse or format the given `val`.
   	 *
   	 * Options:
   	 *
   	 *  - `long` verbose formatting [false]
   	 *
   	 * @param {String|Number} val
   	 * @param {Object} [options]
   	 * @throws {Error} throw an error if val is not a non-empty string or a number
   	 * @return {String|Number}
   	 * @api public
   	 */

   	ms = function (val, options) {
   	  options = options || {};
   	  var type = typeof val;
   	  if (type === 'string' && val.length > 0) {
   	    return parse(val);
   	  } else if (type === 'number' && isFinite(val)) {
   	    return options.long ? fmtLong(val) : fmtShort(val);
   	  }
   	  throw new Error(
   	    'val is not a non-empty string or a valid number. val=' +
   	      JSON.stringify(val)
   	  );
   	};

   	/**
   	 * Parse the given `str` and return milliseconds.
   	 *
   	 * @param {String} str
   	 * @return {Number}
   	 * @api private
   	 */

   	function parse(str) {
   	  str = String(str);
   	  if (str.length > 100) {
   	    return;
   	  }
   	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
   	    str
   	  );
   	  if (!match) {
   	    return;
   	  }
   	  var n = parseFloat(match[1]);
   	  var type = (match[2] || 'ms').toLowerCase();
   	  switch (type) {
   	    case 'years':
   	    case 'year':
   	    case 'yrs':
   	    case 'yr':
   	    case 'y':
   	      return n * y;
   	    case 'weeks':
   	    case 'week':
   	    case 'w':
   	      return n * w;
   	    case 'days':
   	    case 'day':
   	    case 'd':
   	      return n * d;
   	    case 'hours':
   	    case 'hour':
   	    case 'hrs':
   	    case 'hr':
   	    case 'h':
   	      return n * h;
   	    case 'minutes':
   	    case 'minute':
   	    case 'mins':
   	    case 'min':
   	    case 'm':
   	      return n * m;
   	    case 'seconds':
   	    case 'second':
   	    case 'secs':
   	    case 'sec':
   	    case 's':
   	      return n * s;
   	    case 'milliseconds':
   	    case 'millisecond':
   	    case 'msecs':
   	    case 'msec':
   	    case 'ms':
   	      return n;
   	    default:
   	      return undefined;
   	  }
   	}

   	/**
   	 * Short format for `ms`.
   	 *
   	 * @param {Number} ms
   	 * @return {String}
   	 * @api private
   	 */

   	function fmtShort(ms) {
   	  var msAbs = Math.abs(ms);
   	  if (msAbs >= d) {
   	    return Math.round(ms / d) + 'd';
   	  }
   	  if (msAbs >= h) {
   	    return Math.round(ms / h) + 'h';
   	  }
   	  if (msAbs >= m) {
   	    return Math.round(ms / m) + 'm';
   	  }
   	  if (msAbs >= s) {
   	    return Math.round(ms / s) + 's';
   	  }
   	  return ms + 'ms';
   	}

   	/**
   	 * Long format for `ms`.
   	 *
   	 * @param {Number} ms
   	 * @return {String}
   	 * @api private
   	 */

   	function fmtLong(ms) {
   	  var msAbs = Math.abs(ms);
   	  if (msAbs >= d) {
   	    return plural(ms, msAbs, d, 'day');
   	  }
   	  if (msAbs >= h) {
   	    return plural(ms, msAbs, h, 'hour');
   	  }
   	  if (msAbs >= m) {
   	    return plural(ms, msAbs, m, 'minute');
   	  }
   	  if (msAbs >= s) {
   	    return plural(ms, msAbs, s, 'second');
   	  }
   	  return ms + ' ms';
   	}

   	/**
   	 * Pluralization helper.
   	 */

   	function plural(ms, msAbs, n, name) {
   	  var isPlural = msAbs >= n * 1.5;
   	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
   	}
   	return ms;
   }

   var timespan;
   var hasRequiredTimespan;

   function requireTimespan () {
   	if (hasRequiredTimespan) return timespan;
   	hasRequiredTimespan = 1;
   	var ms = requireMs();

   	timespan = function (time, iat) {
   	  var timestamp = iat || Math.floor(Date.now() / 1000);

   	  if (typeof time === 'string') {
   	    var milliseconds = ms(time);
   	    if (typeof milliseconds === 'undefined') {
   	      return;
   	    }
   	    return Math.floor(timestamp + milliseconds / 1000);
   	  } else if (typeof time === 'number') {
   	    return timestamp + time;
   	  } else {
   	    return;
   	  }

   	};
   	return timespan;
   }

   var re = {exports: {}};

   var constants;
   var hasRequiredConstants;

   function requireConstants () {
   	if (hasRequiredConstants) return constants;
   	hasRequiredConstants = 1;
   	// Note: this is the semver.org version of the spec that it implements
   	// Not necessarily the package version of this code.
   	const SEMVER_SPEC_VERSION = '2.0.0';

   	const MAX_LENGTH = 256;
   	const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
   	/* istanbul ignore next */ 9007199254740991;

   	// Max safe segment length for coercion.
   	const MAX_SAFE_COMPONENT_LENGTH = 16;

   	// Max safe length for a build identifier. The max length minus 6 characters for
   	// the shortest version with a build 0.0.0+BUILD.
   	const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;

   	const RELEASE_TYPES = [
   	  'major',
   	  'premajor',
   	  'minor',
   	  'preminor',
   	  'patch',
   	  'prepatch',
   	  'prerelease',
   	];

   	constants = {
   	  MAX_LENGTH,
   	  MAX_SAFE_COMPONENT_LENGTH,
   	  MAX_SAFE_BUILD_LENGTH,
   	  MAX_SAFE_INTEGER,
   	  RELEASE_TYPES,
   	  SEMVER_SPEC_VERSION,
   	  FLAG_INCLUDE_PRERELEASE: 0b001,
   	  FLAG_LOOSE: 0b010,
   	};
   	return constants;
   }

   var debug_1;
   var hasRequiredDebug;

   function requireDebug () {
   	if (hasRequiredDebug) return debug_1;
   	hasRequiredDebug = 1;
   	const debug = (
   	  typeof process === 'object' &&
   	  process.env &&
   	  process.env.NODE_DEBUG &&
   	  /\bsemver\b/i.test(process.env.NODE_DEBUG)
   	) ? (...args) => console.error('SEMVER', ...args)
   	  : () => {};

   	debug_1 = debug;
   	return debug_1;
   }

   var hasRequiredRe;

   function requireRe () {
   	if (hasRequiredRe) return re.exports;
   	hasRequiredRe = 1;
   	(function (module, exports) {
   		const {
   		  MAX_SAFE_COMPONENT_LENGTH,
   		  MAX_SAFE_BUILD_LENGTH,
   		  MAX_LENGTH,
   		} = requireConstants();
   		const debug = requireDebug();
   		exports = module.exports = {};

   		// The actual regexps go on exports.re
   		const re = exports.re = [];
   		const safeRe = exports.safeRe = [];
   		const src = exports.src = [];
   		const safeSrc = exports.safeSrc = [];
   		const t = exports.t = {};
   		let R = 0;

   		const LETTERDASHNUMBER = '[a-zA-Z0-9-]';

   		// Replace some greedy regex tokens to prevent regex dos issues. These regex are
   		// used internally via the safeRe object since all inputs in this library get
   		// normalized first to trim and collapse all extra whitespace. The original
   		// regexes are exported for userland consumption and lower level usage. A
   		// future breaking change could export the safer regex only with a note that
   		// all input should have extra whitespace removed.
   		const safeRegexReplacements = [
   		  ['\\s', 1],
   		  ['\\d', MAX_LENGTH],
   		  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
   		];

   		const makeSafeRegex = (value) => {
   		  for (const [token, max] of safeRegexReplacements) {
   		    value = value
   		      .split(`${token}*`).join(`${token}{0,${max}}`)
   		      .split(`${token}+`).join(`${token}{1,${max}}`);
   		  }
   		  return value
   		};

   		const createToken = (name, value, isGlobal) => {
   		  const safe = makeSafeRegex(value);
   		  const index = R++;
   		  debug(name, index, value);
   		  t[name] = index;
   		  src[index] = value;
   		  safeSrc[index] = safe;
   		  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
   		  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
   		};

   		// The following Regular Expressions can be used for tokenizing,
   		// validating, and parsing SemVer version strings.

   		// ## Numeric Identifier
   		// A single `0`, or a non-zero digit followed by zero or more digits.

   		createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
   		createToken('NUMERICIDENTIFIERLOOSE', '\\d+');

   		// ## Non-numeric Identifier
   		// Zero or more digits, followed by a letter or hyphen, and then zero or
   		// more letters, digits, or hyphens.

   		createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);

   		// ## Main Version
   		// Three dot-separated numeric identifiers.

   		createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
   		                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
   		                   `(${src[t.NUMERICIDENTIFIER]})`);

   		createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
   		                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
   		                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);

   		// ## Pre-release Version Identifier
   		// A numeric identifier, or a non-numeric identifier.

   		createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
		}|${src[t.NONNUMERICIDENTIFIER]})`);

   		createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
		}|${src[t.NONNUMERICIDENTIFIER]})`);

   		// ## Pre-release Version
   		// Hyphen, followed by one or more dot-separated pre-release version
   		// identifiers.

   		createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
		}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);

   		createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
		}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);

   		// ## Build Metadata Identifier
   		// Any combination of digits, letters, or hyphens.

   		createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);

   		// ## Build Metadata
   		// Plus sign, followed by one or more period-separated build metadata
   		// identifiers.

   		createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
		}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);

   		// ## Full Version String
   		// A main version, followed optionally by a pre-release version and
   		// build metadata.

   		// Note that the only major, minor, patch, and pre-release sections of
   		// the version string are capturing groups.  The build metadata is not a
   		// capturing group, because it should not ever be used in version
   		// comparison.

   		createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
		}${src[t.PRERELEASE]}?${
		  src[t.BUILD]}?`);

   		createToken('FULL', `^${src[t.FULLPLAIN]}$`);

   		// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
   		// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
   		// common in the npm registry.
   		createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
		}${src[t.PRERELEASELOOSE]}?${
		  src[t.BUILD]}?`);

   		createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);

   		createToken('GTLT', '((?:<|>)?=?)');

   		// Something like "2.*" or "1.2.x".
   		// Note that "x.x" is a valid xRange identifer, meaning "any version"
   		// Only the first item is strictly required.
   		createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
   		createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);

   		createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
   		                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
   		                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
   		                   `(?:${src[t.PRERELEASE]})?${
		                     src[t.BUILD]}?` +
   		                   `)?)?`);

   		createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
   		                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
   		                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
   		                        `(?:${src[t.PRERELEASELOOSE]})?${
		                          src[t.BUILD]}?` +
   		                        `)?)?`);

   		createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
   		createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);

   		// Coercion.
   		// Extract anything that could conceivably be a part of a valid semver
   		createToken('COERCEPLAIN', `${'(^|[^\\d])' +
		              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
   		              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
   		              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
   		createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
   		createToken('COERCEFULL', src[t.COERCEPLAIN] +
   		              `(?:${src[t.PRERELEASE]})?` +
   		              `(?:${src[t.BUILD]})?` +
   		              `(?:$|[^\\d])`);
   		createToken('COERCERTL', src[t.COERCE], true);
   		createToken('COERCERTLFULL', src[t.COERCEFULL], true);

   		// Tilde ranges.
   		// Meaning is "reasonably at or greater than"
   		createToken('LONETILDE', '(?:~>?)');

   		createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
   		exports.tildeTrimReplace = '$1~';

   		createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
   		createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);

   		// Caret ranges.
   		// Meaning is "at least and backwards compatible with"
   		createToken('LONECARET', '(?:\\^)');

   		createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
   		exports.caretTrimReplace = '$1^';

   		createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
   		createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);

   		// A simple gt/lt/eq thing, or just "" to indicate "any version"
   		createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
   		createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);

   		// An expression to strip any whitespace between the gtlt and the thing
   		// it modifies, so that `> 1.2.3` ==> `>1.2.3`
   		createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
		}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
   		exports.comparatorTrimReplace = '$1$2$3';

   		// Something like `1.2.3 - 1.2.4`
   		// Note that these all use the loose form, because they'll be
   		// checked against either the strict or loose comparator form
   		// later.
   		createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
   		                   `\\s+-\\s+` +
   		                   `(${src[t.XRANGEPLAIN]})` +
   		                   `\\s*$`);

   		createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
   		                        `\\s+-\\s+` +
   		                        `(${src[t.XRANGEPLAINLOOSE]})` +
   		                        `\\s*$`);

   		// Star ranges basically just allow anything at all.
   		createToken('STAR', '(<|>)?=?\\s*\\*');
   		// >=0.0.0 is like a star
   		createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
   		createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$'); 
   	} (re, re.exports));
   	return re.exports;
   }

   var parseOptions_1;
   var hasRequiredParseOptions;

   function requireParseOptions () {
   	if (hasRequiredParseOptions) return parseOptions_1;
   	hasRequiredParseOptions = 1;
   	// parse out just the options we care about
   	const looseOption = Object.freeze({ loose: true });
   	const emptyOpts = Object.freeze({ });
   	const parseOptions = options => {
   	  if (!options) {
   	    return emptyOpts
   	  }

   	  if (typeof options !== 'object') {
   	    return looseOption
   	  }

   	  return options
   	};
   	parseOptions_1 = parseOptions;
   	return parseOptions_1;
   }

   var identifiers;
   var hasRequiredIdentifiers;

   function requireIdentifiers () {
   	if (hasRequiredIdentifiers) return identifiers;
   	hasRequiredIdentifiers = 1;
   	const numeric = /^[0-9]+$/;
   	const compareIdentifiers = (a, b) => {
   	  const anum = numeric.test(a);
   	  const bnum = numeric.test(b);

   	  if (anum && bnum) {
   	    a = +a;
   	    b = +b;
   	  }

   	  return a === b ? 0
   	    : (anum && !bnum) ? -1
   	    : (bnum && !anum) ? 1
   	    : a < b ? -1
   	    : 1
   	};

   	const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);

   	identifiers = {
   	  compareIdentifiers,
   	  rcompareIdentifiers,
   	};
   	return identifiers;
   }

   var semver$1;
   var hasRequiredSemver$1;

   function requireSemver$1 () {
   	if (hasRequiredSemver$1) return semver$1;
   	hasRequiredSemver$1 = 1;
   	const debug = requireDebug();
   	const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants();
   	const { safeRe: re, safeSrc: src, t } = requireRe();

   	const parseOptions = requireParseOptions();
   	const { compareIdentifiers } = requireIdentifiers();
   	class SemVer {
   	  constructor (version, options) {
   	    options = parseOptions(options);

   	    if (version instanceof SemVer) {
   	      if (version.loose === !!options.loose &&
   	        version.includePrerelease === !!options.includePrerelease) {
   	        return version
   	      } else {
   	        version = version.version;
   	      }
   	    } else if (typeof version !== 'string') {
   	      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
   	    }

   	    if (version.length > MAX_LENGTH) {
   	      throw new TypeError(
   	        `version is longer than ${MAX_LENGTH} characters`
   	      )
   	    }

   	    debug('SemVer', version, options);
   	    this.options = options;
   	    this.loose = !!options.loose;
   	    // this isn't actually relevant for versions, but keep it so that we
   	    // don't run into trouble passing this.options around.
   	    this.includePrerelease = !!options.includePrerelease;

   	    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

   	    if (!m) {
   	      throw new TypeError(`Invalid Version: ${version}`)
   	    }

   	    this.raw = version;

   	    // these are actually numbers
   	    this.major = +m[1];
   	    this.minor = +m[2];
   	    this.patch = +m[3];

   	    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
   	      throw new TypeError('Invalid major version')
   	    }

   	    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
   	      throw new TypeError('Invalid minor version')
   	    }

   	    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
   	      throw new TypeError('Invalid patch version')
   	    }

   	    // numberify any prerelease numeric ids
   	    if (!m[4]) {
   	      this.prerelease = [];
   	    } else {
   	      this.prerelease = m[4].split('.').map((id) => {
   	        if (/^[0-9]+$/.test(id)) {
   	          const num = +id;
   	          if (num >= 0 && num < MAX_SAFE_INTEGER) {
   	            return num
   	          }
   	        }
   	        return id
   	      });
   	    }

   	    this.build = m[5] ? m[5].split('.') : [];
   	    this.format();
   	  }

   	  format () {
   	    this.version = `${this.major}.${this.minor}.${this.patch}`;
   	    if (this.prerelease.length) {
   	      this.version += `-${this.prerelease.join('.')}`;
   	    }
   	    return this.version
   	  }

   	  toString () {
   	    return this.version
   	  }

   	  compare (other) {
   	    debug('SemVer.compare', this.version, this.options, other);
   	    if (!(other instanceof SemVer)) {
   	      if (typeof other === 'string' && other === this.version) {
   	        return 0
   	      }
   	      other = new SemVer(other, this.options);
   	    }

   	    if (other.version === this.version) {
   	      return 0
   	    }

   	    return this.compareMain(other) || this.comparePre(other)
   	  }

   	  compareMain (other) {
   	    if (!(other instanceof SemVer)) {
   	      other = new SemVer(other, this.options);
   	    }

   	    return (
   	      compareIdentifiers(this.major, other.major) ||
   	      compareIdentifiers(this.minor, other.minor) ||
   	      compareIdentifiers(this.patch, other.patch)
   	    )
   	  }

   	  comparePre (other) {
   	    if (!(other instanceof SemVer)) {
   	      other = new SemVer(other, this.options);
   	    }

   	    // NOT having a prerelease is > having one
   	    if (this.prerelease.length && !other.prerelease.length) {
   	      return -1
   	    } else if (!this.prerelease.length && other.prerelease.length) {
   	      return 1
   	    } else if (!this.prerelease.length && !other.prerelease.length) {
   	      return 0
   	    }

   	    let i = 0;
   	    do {
   	      const a = this.prerelease[i];
   	      const b = other.prerelease[i];
   	      debug('prerelease compare', i, a, b);
   	      if (a === undefined && b === undefined) {
   	        return 0
   	      } else if (b === undefined) {
   	        return 1
   	      } else if (a === undefined) {
   	        return -1
   	      } else if (a === b) {
   	        continue
   	      } else {
   	        return compareIdentifiers(a, b)
   	      }
   	    } while (++i)
   	  }

   	  compareBuild (other) {
   	    if (!(other instanceof SemVer)) {
   	      other = new SemVer(other, this.options);
   	    }

   	    let i = 0;
   	    do {
   	      const a = this.build[i];
   	      const b = other.build[i];
   	      debug('build compare', i, a, b);
   	      if (a === undefined && b === undefined) {
   	        return 0
   	      } else if (b === undefined) {
   	        return 1
   	      } else if (a === undefined) {
   	        return -1
   	      } else if (a === b) {
   	        continue
   	      } else {
   	        return compareIdentifiers(a, b)
   	      }
   	    } while (++i)
   	  }

   	  // preminor will bump the version up to the next minor release, and immediately
   	  // down to pre-release. premajor and prepatch work the same way.
   	  inc (release, identifier, identifierBase) {
   	    if (release.startsWith('pre')) {
   	      if (!identifier && identifierBase === false) {
   	        throw new Error('invalid increment argument: identifier is empty')
   	      }
   	      // Avoid an invalid semver results
   	      if (identifier) {
   	        const r = new RegExp(`^${this.options.loose ? src[t.PRERELEASELOOSE] : src[t.PRERELEASE]}$`);
   	        const match = `-${identifier}`.match(r);
   	        if (!match || match[1] !== identifier) {
   	          throw new Error(`invalid identifier: ${identifier}`)
   	        }
   	      }
   	    }

   	    switch (release) {
   	      case 'premajor':
   	        this.prerelease.length = 0;
   	        this.patch = 0;
   	        this.minor = 0;
   	        this.major++;
   	        this.inc('pre', identifier, identifierBase);
   	        break
   	      case 'preminor':
   	        this.prerelease.length = 0;
   	        this.patch = 0;
   	        this.minor++;
   	        this.inc('pre', identifier, identifierBase);
   	        break
   	      case 'prepatch':
   	        // If this is already a prerelease, it will bump to the next version
   	        // drop any prereleases that might already exist, since they are not
   	        // relevant at this point.
   	        this.prerelease.length = 0;
   	        this.inc('patch', identifier, identifierBase);
   	        this.inc('pre', identifier, identifierBase);
   	        break
   	      // If the input is a non-prerelease version, this acts the same as
   	      // prepatch.
   	      case 'prerelease':
   	        if (this.prerelease.length === 0) {
   	          this.inc('patch', identifier, identifierBase);
   	        }
   	        this.inc('pre', identifier, identifierBase);
   	        break
   	      case 'release':
   	        if (this.prerelease.length === 0) {
   	          throw new Error(`version ${this.raw} is not a prerelease`)
   	        }
   	        this.prerelease.length = 0;
   	        break

   	      case 'major':
   	        // If this is a pre-major version, bump up to the same major version.
   	        // Otherwise increment major.
   	        // 1.0.0-5 bumps to 1.0.0
   	        // 1.1.0 bumps to 2.0.0
   	        if (
   	          this.minor !== 0 ||
   	          this.patch !== 0 ||
   	          this.prerelease.length === 0
   	        ) {
   	          this.major++;
   	        }
   	        this.minor = 0;
   	        this.patch = 0;
   	        this.prerelease = [];
   	        break
   	      case 'minor':
   	        // If this is a pre-minor version, bump up to the same minor version.
   	        // Otherwise increment minor.
   	        // 1.2.0-5 bumps to 1.2.0
   	        // 1.2.1 bumps to 1.3.0
   	        if (this.patch !== 0 || this.prerelease.length === 0) {
   	          this.minor++;
   	        }
   	        this.patch = 0;
   	        this.prerelease = [];
   	        break
   	      case 'patch':
   	        // If this is not a pre-release version, it will increment the patch.
   	        // If it is a pre-release it will bump up to the same patch version.
   	        // 1.2.0-5 patches to 1.2.0
   	        // 1.2.0 patches to 1.2.1
   	        if (this.prerelease.length === 0) {
   	          this.patch++;
   	        }
   	        this.prerelease = [];
   	        break
   	      // This probably shouldn't be used publicly.
   	      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
   	      case 'pre': {
   	        const base = Number(identifierBase) ? 1 : 0;

   	        if (this.prerelease.length === 0) {
   	          this.prerelease = [base];
   	        } else {
   	          let i = this.prerelease.length;
   	          while (--i >= 0) {
   	            if (typeof this.prerelease[i] === 'number') {
   	              this.prerelease[i]++;
   	              i = -2;
   	            }
   	          }
   	          if (i === -1) {
   	            // didn't increment anything
   	            if (identifier === this.prerelease.join('.') && identifierBase === false) {
   	              throw new Error('invalid increment argument: identifier already exists')
   	            }
   	            this.prerelease.push(base);
   	          }
   	        }
   	        if (identifier) {
   	          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
   	          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
   	          let prerelease = [identifier, base];
   	          if (identifierBase === false) {
   	            prerelease = [identifier];
   	          }
   	          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
   	            if (isNaN(this.prerelease[1])) {
   	              this.prerelease = prerelease;
   	            }
   	          } else {
   	            this.prerelease = prerelease;
   	          }
   	        }
   	        break
   	      }
   	      default:
   	        throw new Error(`invalid increment argument: ${release}`)
   	    }
   	    this.raw = this.format();
   	    if (this.build.length) {
   	      this.raw += `+${this.build.join('.')}`;
   	    }
   	    return this
   	  }
   	}

   	semver$1 = SemVer;
   	return semver$1;
   }

   var parse_1;
   var hasRequiredParse;

   function requireParse () {
   	if (hasRequiredParse) return parse_1;
   	hasRequiredParse = 1;
   	const SemVer = requireSemver$1();
   	const parse = (version, options, throwErrors = false) => {
   	  if (version instanceof SemVer) {
   	    return version
   	  }
   	  try {
   	    return new SemVer(version, options)
   	  } catch (er) {
   	    if (!throwErrors) {
   	      return null
   	    }
   	    throw er
   	  }
   	};

   	parse_1 = parse;
   	return parse_1;
   }

   var valid_1;
   var hasRequiredValid$1;

   function requireValid$1 () {
   	if (hasRequiredValid$1) return valid_1;
   	hasRequiredValid$1 = 1;
   	const parse = requireParse();
   	const valid = (version, options) => {
   	  const v = parse(version, options);
   	  return v ? v.version : null
   	};
   	valid_1 = valid;
   	return valid_1;
   }

   var clean_1;
   var hasRequiredClean;

   function requireClean () {
   	if (hasRequiredClean) return clean_1;
   	hasRequiredClean = 1;
   	const parse = requireParse();
   	const clean = (version, options) => {
   	  const s = parse(version.trim().replace(/^[=v]+/, ''), options);
   	  return s ? s.version : null
   	};
   	clean_1 = clean;
   	return clean_1;
   }

   var inc_1;
   var hasRequiredInc;

   function requireInc () {
   	if (hasRequiredInc) return inc_1;
   	hasRequiredInc = 1;
   	const SemVer = requireSemver$1();

   	const inc = (version, release, options, identifier, identifierBase) => {
   	  if (typeof (options) === 'string') {
   	    identifierBase = identifier;
   	    identifier = options;
   	    options = undefined;
   	  }

   	  try {
   	    return new SemVer(
   	      version instanceof SemVer ? version.version : version,
   	      options
   	    ).inc(release, identifier, identifierBase).version
   	  } catch (er) {
   	    return null
   	  }
   	};
   	inc_1 = inc;
   	return inc_1;
   }

   var diff_1;
   var hasRequiredDiff;

   function requireDiff () {
   	if (hasRequiredDiff) return diff_1;
   	hasRequiredDiff = 1;
   	const parse = requireParse();

   	const diff = (version1, version2) => {
   	  const v1 = parse(version1, null, true);
   	  const v2 = parse(version2, null, true);
   	  const comparison = v1.compare(v2);

   	  if (comparison === 0) {
   	    return null
   	  }

   	  const v1Higher = comparison > 0;
   	  const highVersion = v1Higher ? v1 : v2;
   	  const lowVersion = v1Higher ? v2 : v1;
   	  const highHasPre = !!highVersion.prerelease.length;
   	  const lowHasPre = !!lowVersion.prerelease.length;

   	  if (lowHasPre && !highHasPre) {
   	    // Going from prerelease -> no prerelease requires some special casing

   	    // If the low version has only a major, then it will always be a major
   	    // Some examples:
   	    // 1.0.0-1 -> 1.0.0
   	    // 1.0.0-1 -> 1.1.1
   	    // 1.0.0-1 -> 2.0.0
   	    if (!lowVersion.patch && !lowVersion.minor) {
   	      return 'major'
   	    }

   	    // If the main part has no difference
   	    if (lowVersion.compareMain(highVersion) === 0) {
   	      if (lowVersion.minor && !lowVersion.patch) {
   	        return 'minor'
   	      }
   	      return 'patch'
   	    }
   	  }

   	  // add the `pre` prefix if we are going to a prerelease version
   	  const prefix = highHasPre ? 'pre' : '';

   	  if (v1.major !== v2.major) {
   	    return prefix + 'major'
   	  }

   	  if (v1.minor !== v2.minor) {
   	    return prefix + 'minor'
   	  }

   	  if (v1.patch !== v2.patch) {
   	    return prefix + 'patch'
   	  }

   	  // high and low are preleases
   	  return 'prerelease'
   	};

   	diff_1 = diff;
   	return diff_1;
   }

   var major_1;
   var hasRequiredMajor;

   function requireMajor () {
   	if (hasRequiredMajor) return major_1;
   	hasRequiredMajor = 1;
   	const SemVer = requireSemver$1();
   	const major = (a, loose) => new SemVer(a, loose).major;
   	major_1 = major;
   	return major_1;
   }

   var minor_1;
   var hasRequiredMinor;

   function requireMinor () {
   	if (hasRequiredMinor) return minor_1;
   	hasRequiredMinor = 1;
   	const SemVer = requireSemver$1();
   	const minor = (a, loose) => new SemVer(a, loose).minor;
   	minor_1 = minor;
   	return minor_1;
   }

   var patch_1;
   var hasRequiredPatch;

   function requirePatch () {
   	if (hasRequiredPatch) return patch_1;
   	hasRequiredPatch = 1;
   	const SemVer = requireSemver$1();
   	const patch = (a, loose) => new SemVer(a, loose).patch;
   	patch_1 = patch;
   	return patch_1;
   }

   var prerelease_1;
   var hasRequiredPrerelease;

   function requirePrerelease () {
   	if (hasRequiredPrerelease) return prerelease_1;
   	hasRequiredPrerelease = 1;
   	const parse = requireParse();
   	const prerelease = (version, options) => {
   	  const parsed = parse(version, options);
   	  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
   	};
   	prerelease_1 = prerelease;
   	return prerelease_1;
   }

   var compare_1;
   var hasRequiredCompare;

   function requireCompare () {
   	if (hasRequiredCompare) return compare_1;
   	hasRequiredCompare = 1;
   	const SemVer = requireSemver$1();
   	const compare = (a, b, loose) =>
   	  new SemVer(a, loose).compare(new SemVer(b, loose));

   	compare_1 = compare;
   	return compare_1;
   }

   var rcompare_1;
   var hasRequiredRcompare;

   function requireRcompare () {
   	if (hasRequiredRcompare) return rcompare_1;
   	hasRequiredRcompare = 1;
   	const compare = requireCompare();
   	const rcompare = (a, b, loose) => compare(b, a, loose);
   	rcompare_1 = rcompare;
   	return rcompare_1;
   }

   var compareLoose_1;
   var hasRequiredCompareLoose;

   function requireCompareLoose () {
   	if (hasRequiredCompareLoose) return compareLoose_1;
   	hasRequiredCompareLoose = 1;
   	const compare = requireCompare();
   	const compareLoose = (a, b) => compare(a, b, true);
   	compareLoose_1 = compareLoose;
   	return compareLoose_1;
   }

   var compareBuild_1;
   var hasRequiredCompareBuild;

   function requireCompareBuild () {
   	if (hasRequiredCompareBuild) return compareBuild_1;
   	hasRequiredCompareBuild = 1;
   	const SemVer = requireSemver$1();
   	const compareBuild = (a, b, loose) => {
   	  const versionA = new SemVer(a, loose);
   	  const versionB = new SemVer(b, loose);
   	  return versionA.compare(versionB) || versionA.compareBuild(versionB)
   	};
   	compareBuild_1 = compareBuild;
   	return compareBuild_1;
   }

   var sort_1;
   var hasRequiredSort;

   function requireSort () {
   	if (hasRequiredSort) return sort_1;
   	hasRequiredSort = 1;
   	const compareBuild = requireCompareBuild();
   	const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
   	sort_1 = sort;
   	return sort_1;
   }

   var rsort_1;
   var hasRequiredRsort;

   function requireRsort () {
   	if (hasRequiredRsort) return rsort_1;
   	hasRequiredRsort = 1;
   	const compareBuild = requireCompareBuild();
   	const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
   	rsort_1 = rsort;
   	return rsort_1;
   }

   var gt_1;
   var hasRequiredGt;

   function requireGt () {
   	if (hasRequiredGt) return gt_1;
   	hasRequiredGt = 1;
   	const compare = requireCompare();
   	const gt = (a, b, loose) => compare(a, b, loose) > 0;
   	gt_1 = gt;
   	return gt_1;
   }

   var lt_1;
   var hasRequiredLt;

   function requireLt () {
   	if (hasRequiredLt) return lt_1;
   	hasRequiredLt = 1;
   	const compare = requireCompare();
   	const lt = (a, b, loose) => compare(a, b, loose) < 0;
   	lt_1 = lt;
   	return lt_1;
   }

   var eq_1;
   var hasRequiredEq;

   function requireEq () {
   	if (hasRequiredEq) return eq_1;
   	hasRequiredEq = 1;
   	const compare = requireCompare();
   	const eq = (a, b, loose) => compare(a, b, loose) === 0;
   	eq_1 = eq;
   	return eq_1;
   }

   var neq_1;
   var hasRequiredNeq;

   function requireNeq () {
   	if (hasRequiredNeq) return neq_1;
   	hasRequiredNeq = 1;
   	const compare = requireCompare();
   	const neq = (a, b, loose) => compare(a, b, loose) !== 0;
   	neq_1 = neq;
   	return neq_1;
   }

   var gte_1;
   var hasRequiredGte;

   function requireGte () {
   	if (hasRequiredGte) return gte_1;
   	hasRequiredGte = 1;
   	const compare = requireCompare();
   	const gte = (a, b, loose) => compare(a, b, loose) >= 0;
   	gte_1 = gte;
   	return gte_1;
   }

   var lte_1;
   var hasRequiredLte;

   function requireLte () {
   	if (hasRequiredLte) return lte_1;
   	hasRequiredLte = 1;
   	const compare = requireCompare();
   	const lte = (a, b, loose) => compare(a, b, loose) <= 0;
   	lte_1 = lte;
   	return lte_1;
   }

   var cmp_1;
   var hasRequiredCmp;

   function requireCmp () {
   	if (hasRequiredCmp) return cmp_1;
   	hasRequiredCmp = 1;
   	const eq = requireEq();
   	const neq = requireNeq();
   	const gt = requireGt();
   	const gte = requireGte();
   	const lt = requireLt();
   	const lte = requireLte();

   	const cmp = (a, op, b, loose) => {
   	  switch (op) {
   	    case '===':
   	      if (typeof a === 'object') {
   	        a = a.version;
   	      }
   	      if (typeof b === 'object') {
   	        b = b.version;
   	      }
   	      return a === b

   	    case '!==':
   	      if (typeof a === 'object') {
   	        a = a.version;
   	      }
   	      if (typeof b === 'object') {
   	        b = b.version;
   	      }
   	      return a !== b

   	    case '':
   	    case '=':
   	    case '==':
   	      return eq(a, b, loose)

   	    case '!=':
   	      return neq(a, b, loose)

   	    case '>':
   	      return gt(a, b, loose)

   	    case '>=':
   	      return gte(a, b, loose)

   	    case '<':
   	      return lt(a, b, loose)

   	    case '<=':
   	      return lte(a, b, loose)

   	    default:
   	      throw new TypeError(`Invalid operator: ${op}`)
   	  }
   	};
   	cmp_1 = cmp;
   	return cmp_1;
   }

   var coerce_1;
   var hasRequiredCoerce;

   function requireCoerce () {
   	if (hasRequiredCoerce) return coerce_1;
   	hasRequiredCoerce = 1;
   	const SemVer = requireSemver$1();
   	const parse = requireParse();
   	const { safeRe: re, t } = requireRe();

   	const coerce = (version, options) => {
   	  if (version instanceof SemVer) {
   	    return version
   	  }

   	  if (typeof version === 'number') {
   	    version = String(version);
   	  }

   	  if (typeof version !== 'string') {
   	    return null
   	  }

   	  options = options || {};

   	  let match = null;
   	  if (!options.rtl) {
   	    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
   	  } else {
   	    // Find the right-most coercible string that does not share
   	    // a terminus with a more left-ward coercible string.
   	    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
   	    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
   	    //
   	    // Walk through the string checking with a /g regexp
   	    // Manually set the index so as to pick up overlapping matches.
   	    // Stop when we get a match that ends at the string end, since no
   	    // coercible string can be more right-ward without the same terminus.
   	    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
   	    let next;
   	    while ((next = coerceRtlRegex.exec(version)) &&
   	        (!match || match.index + match[0].length !== version.length)
   	    ) {
   	      if (!match ||
   	            next.index + next[0].length !== match.index + match[0].length) {
   	        match = next;
   	      }
   	      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
   	    }
   	    // leave it in a clean state
   	    coerceRtlRegex.lastIndex = -1;
   	  }

   	  if (match === null) {
   	    return null
   	  }

   	  const major = match[2];
   	  const minor = match[3] || '0';
   	  const patch = match[4] || '0';
   	  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
   	  const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';

   	  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)
   	};
   	coerce_1 = coerce;
   	return coerce_1;
   }

   var lrucache;
   var hasRequiredLrucache;

   function requireLrucache () {
   	if (hasRequiredLrucache) return lrucache;
   	hasRequiredLrucache = 1;
   	class LRUCache {
   	  constructor () {
   	    this.max = 1000;
   	    this.map = new Map();
   	  }

   	  get (key) {
   	    const value = this.map.get(key);
   	    if (value === undefined) {
   	      return undefined
   	    } else {
   	      // Remove the key from the map and add it to the end
   	      this.map.delete(key);
   	      this.map.set(key, value);
   	      return value
   	    }
   	  }

   	  delete (key) {
   	    return this.map.delete(key)
   	  }

   	  set (key, value) {
   	    const deleted = this.delete(key);

   	    if (!deleted && value !== undefined) {
   	      // If cache is full, delete the least recently used item
   	      if (this.map.size >= this.max) {
   	        const firstKey = this.map.keys().next().value;
   	        this.delete(firstKey);
   	      }

   	      this.map.set(key, value);
   	    }

   	    return this
   	  }
   	}

   	lrucache = LRUCache;
   	return lrucache;
   }

   var range;
   var hasRequiredRange;

   function requireRange () {
   	if (hasRequiredRange) return range;
   	hasRequiredRange = 1;
   	const SPACE_CHARACTERS = /\s+/g;

   	// hoisted class for cyclic dependency
   	class Range {
   	  constructor (range, options) {
   	    options = parseOptions(options);

   	    if (range instanceof Range) {
   	      if (
   	        range.loose === !!options.loose &&
   	        range.includePrerelease === !!options.includePrerelease
   	      ) {
   	        return range
   	      } else {
   	        return new Range(range.raw, options)
   	      }
   	    }

   	    if (range instanceof Comparator) {
   	      // just put it in the set and return
   	      this.raw = range.value;
   	      this.set = [[range]];
   	      this.formatted = undefined;
   	      return this
   	    }

   	    this.options = options;
   	    this.loose = !!options.loose;
   	    this.includePrerelease = !!options.includePrerelease;

   	    // First reduce all whitespace as much as possible so we do not have to rely
   	    // on potentially slow regexes like \s*. This is then stored and used for
   	    // future error messages as well.
   	    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');

   	    // First, split on ||
   	    this.set = this.raw
   	      .split('||')
   	      // map the range to a 2d array of comparators
   	      .map(r => this.parseRange(r.trim()))
   	      // throw out any comparator lists that are empty
   	      // this generally means that it was not a valid range, which is allowed
   	      // in loose mode, but will still throw if the WHOLE range is invalid.
   	      .filter(c => c.length);

   	    if (!this.set.length) {
   	      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
   	    }

   	    // if we have any that are not the null set, throw out null sets.
   	    if (this.set.length > 1) {
   	      // keep the first one, in case they're all null sets
   	      const first = this.set[0];
   	      this.set = this.set.filter(c => !isNullSet(c[0]));
   	      if (this.set.length === 0) {
   	        this.set = [first];
   	      } else if (this.set.length > 1) {
   	        // if we have any that are *, then the range is just *
   	        for (const c of this.set) {
   	          if (c.length === 1 && isAny(c[0])) {
   	            this.set = [c];
   	            break
   	          }
   	        }
   	      }
   	    }

   	    this.formatted = undefined;
   	  }

   	  get range () {
   	    if (this.formatted === undefined) {
   	      this.formatted = '';
   	      for (let i = 0; i < this.set.length; i++) {
   	        if (i > 0) {
   	          this.formatted += '||';
   	        }
   	        const comps = this.set[i];
   	        for (let k = 0; k < comps.length; k++) {
   	          if (k > 0) {
   	            this.formatted += ' ';
   	          }
   	          this.formatted += comps[k].toString().trim();
   	        }
   	      }
   	    }
   	    return this.formatted
   	  }

   	  format () {
   	    return this.range
   	  }

   	  toString () {
   	    return this.range
   	  }

   	  parseRange (range) {
   	    // memoize range parsing for performance.
   	    // this is a very hot path, and fully deterministic.
   	    const memoOpts =
   	      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
   	      (this.options.loose && FLAG_LOOSE);
   	    const memoKey = memoOpts + ':' + range;
   	    const cached = cache.get(memoKey);
   	    if (cached) {
   	      return cached
   	    }

   	    const loose = this.options.loose;
   	    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
   	    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
   	    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
   	    debug('hyphen replace', range);

   	    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
   	    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
   	    debug('comparator trim', range);

   	    // `~ 1.2.3` => `~1.2.3`
   	    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
   	    debug('tilde trim', range);

   	    // `^ 1.2.3` => `^1.2.3`
   	    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
   	    debug('caret trim', range);

   	    // At this point, the range is completely trimmed and
   	    // ready to be split into comparators.

   	    let rangeList = range
   	      .split(' ')
   	      .map(comp => parseComparator(comp, this.options))
   	      .join(' ')
   	      .split(/\s+/)
   	      // >=0.0.0 is equivalent to *
   	      .map(comp => replaceGTE0(comp, this.options));

   	    if (loose) {
   	      // in loose mode, throw out any that are not valid comparators
   	      rangeList = rangeList.filter(comp => {
   	        debug('loose invalid filter', comp, this.options);
   	        return !!comp.match(re[t.COMPARATORLOOSE])
   	      });
   	    }
   	    debug('range list', rangeList);

   	    // if any comparators are the null set, then replace with JUST null set
   	    // if more than one comparator, remove any * comparators
   	    // also, don't include the same comparator more than once
   	    const rangeMap = new Map();
   	    const comparators = rangeList.map(comp => new Comparator(comp, this.options));
   	    for (const comp of comparators) {
   	      if (isNullSet(comp)) {
   	        return [comp]
   	      }
   	      rangeMap.set(comp.value, comp);
   	    }
   	    if (rangeMap.size > 1 && rangeMap.has('')) {
   	      rangeMap.delete('');
   	    }

   	    const result = [...rangeMap.values()];
   	    cache.set(memoKey, result);
   	    return result
   	  }

   	  intersects (range, options) {
   	    if (!(range instanceof Range)) {
   	      throw new TypeError('a Range is required')
   	    }

   	    return this.set.some((thisComparators) => {
   	      return (
   	        isSatisfiable(thisComparators, options) &&
   	        range.set.some((rangeComparators) => {
   	          return (
   	            isSatisfiable(rangeComparators, options) &&
   	            thisComparators.every((thisComparator) => {
   	              return rangeComparators.every((rangeComparator) => {
   	                return thisComparator.intersects(rangeComparator, options)
   	              })
   	            })
   	          )
   	        })
   	      )
   	    })
   	  }

   	  // if ANY of the sets match ALL of its comparators, then pass
   	  test (version) {
   	    if (!version) {
   	      return false
   	    }

   	    if (typeof version === 'string') {
   	      try {
   	        version = new SemVer(version, this.options);
   	      } catch (er) {
   	        return false
   	      }
   	    }

   	    for (let i = 0; i < this.set.length; i++) {
   	      if (testSet(this.set[i], version, this.options)) {
   	        return true
   	      }
   	    }
   	    return false
   	  }
   	}

   	range = Range;

   	const LRU = requireLrucache();
   	const cache = new LRU();

   	const parseOptions = requireParseOptions();
   	const Comparator = requireComparator();
   	const debug = requireDebug();
   	const SemVer = requireSemver$1();
   	const {
   	  safeRe: re,
   	  t,
   	  comparatorTrimReplace,
   	  tildeTrimReplace,
   	  caretTrimReplace,
   	} = requireRe();
   	const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants();

   	const isNullSet = c => c.value === '<0.0.0-0';
   	const isAny = c => c.value === '';

   	// take a set of comparators and determine whether there
   	// exists a version which can satisfy it
   	const isSatisfiable = (comparators, options) => {
   	  let result = true;
   	  const remainingComparators = comparators.slice();
   	  let testComparator = remainingComparators.pop();

   	  while (result && remainingComparators.length) {
   	    result = remainingComparators.every((otherComparator) => {
   	      return testComparator.intersects(otherComparator, options)
   	    });

   	    testComparator = remainingComparators.pop();
   	  }

   	  return result
   	};

   	// comprised of xranges, tildes, stars, and gtlt's at this point.
   	// already replaced the hyphen ranges
   	// turn into a set of JUST comparators.
   	const parseComparator = (comp, options) => {
   	  debug('comp', comp, options);
   	  comp = replaceCarets(comp, options);
   	  debug('caret', comp);
   	  comp = replaceTildes(comp, options);
   	  debug('tildes', comp);
   	  comp = replaceXRanges(comp, options);
   	  debug('xrange', comp);
   	  comp = replaceStars(comp, options);
   	  debug('stars', comp);
   	  return comp
   	};

   	const isX = id => !id || id.toLowerCase() === 'x' || id === '*';

   	// ~, ~> --> * (any, kinda silly)
   	// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
   	// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
   	// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
   	// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
   	// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
   	// ~0.0.1 --> >=0.0.1 <0.1.0-0
   	const replaceTildes = (comp, options) => {
   	  return comp
   	    .trim()
   	    .split(/\s+/)
   	    .map((c) => replaceTilde(c, options))
   	    .join(' ')
   	};

   	const replaceTilde = (comp, options) => {
   	  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
   	  return comp.replace(r, (_, M, m, p, pr) => {
   	    debug('tilde', comp, _, M, m, p, pr);
   	    let ret;

   	    if (isX(M)) {
   	      ret = '';
   	    } else if (isX(m)) {
   	      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
   	    } else if (isX(p)) {
   	      // ~1.2 == >=1.2.0 <1.3.0-0
   	      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
   	    } else if (pr) {
   	      debug('replaceTilde pr', pr);
   	      ret = `>=${M}.${m}.${p}-${pr
	      } <${M}.${+m + 1}.0-0`;
   	    } else {
   	      // ~1.2.3 == >=1.2.3 <1.3.0-0
   	      ret = `>=${M}.${m}.${p
	      } <${M}.${+m + 1}.0-0`;
   	    }

   	    debug('tilde return', ret);
   	    return ret
   	  })
   	};

   	// ^ --> * (any, kinda silly)
   	// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
   	// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
   	// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
   	// ^1.2.3 --> >=1.2.3 <2.0.0-0
   	// ^1.2.0 --> >=1.2.0 <2.0.0-0
   	// ^0.0.1 --> >=0.0.1 <0.0.2-0
   	// ^0.1.0 --> >=0.1.0 <0.2.0-0
   	const replaceCarets = (comp, options) => {
   	  return comp
   	    .trim()
   	    .split(/\s+/)
   	    .map((c) => replaceCaret(c, options))
   	    .join(' ')
   	};

   	const replaceCaret = (comp, options) => {
   	  debug('caret', comp, options);
   	  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
   	  const z = options.includePrerelease ? '-0' : '';
   	  return comp.replace(r, (_, M, m, p, pr) => {
   	    debug('caret', comp, _, M, m, p, pr);
   	    let ret;

   	    if (isX(M)) {
   	      ret = '';
   	    } else if (isX(m)) {
   	      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
   	    } else if (isX(p)) {
   	      if (M === '0') {
   	        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
   	      } else {
   	        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
   	      }
   	    } else if (pr) {
   	      debug('replaceCaret pr', pr);
   	      if (M === '0') {
   	        if (m === '0') {
   	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${m}.${+p + 1}-0`;
   	        } else {
   	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${+m + 1}.0-0`;
   	        }
   	      } else {
   	        ret = `>=${M}.${m}.${p}-${pr
	        } <${+M + 1}.0.0-0`;
   	      }
   	    } else {
   	      debug('no pr');
   	      if (M === '0') {
   	        if (m === '0') {
   	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${m}.${+p + 1}-0`;
   	        } else {
   	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${+m + 1}.0-0`;
   	        }
   	      } else {
   	        ret = `>=${M}.${m}.${p
	        } <${+M + 1}.0.0-0`;
   	      }
   	    }

   	    debug('caret return', ret);
   	    return ret
   	  })
   	};

   	const replaceXRanges = (comp, options) => {
   	  debug('replaceXRanges', comp, options);
   	  return comp
   	    .split(/\s+/)
   	    .map((c) => replaceXRange(c, options))
   	    .join(' ')
   	};

   	const replaceXRange = (comp, options) => {
   	  comp = comp.trim();
   	  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
   	  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
   	    debug('xRange', comp, ret, gtlt, M, m, p, pr);
   	    const xM = isX(M);
   	    const xm = xM || isX(m);
   	    const xp = xm || isX(p);
   	    const anyX = xp;

   	    if (gtlt === '=' && anyX) {
   	      gtlt = '';
   	    }

   	    // if we're including prereleases in the match, then we need
   	    // to fix this to -0, the lowest possible prerelease value
   	    pr = options.includePrerelease ? '-0' : '';

   	    if (xM) {
   	      if (gtlt === '>' || gtlt === '<') {
   	        // nothing is allowed
   	        ret = '<0.0.0-0';
   	      } else {
   	        // nothing is forbidden
   	        ret = '*';
   	      }
   	    } else if (gtlt && anyX) {
   	      // we know patch is an x, because we have any x at all.
   	      // replace X with 0
   	      if (xm) {
   	        m = 0;
   	      }
   	      p = 0;

   	      if (gtlt === '>') {
   	        // >1 => >=2.0.0
   	        // >1.2 => >=1.3.0
   	        gtlt = '>=';
   	        if (xm) {
   	          M = +M + 1;
   	          m = 0;
   	          p = 0;
   	        } else {
   	          m = +m + 1;
   	          p = 0;
   	        }
   	      } else if (gtlt === '<=') {
   	        // <=0.7.x is actually <0.8.0, since any 0.7.x should
   	        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
   	        gtlt = '<';
   	        if (xm) {
   	          M = +M + 1;
   	        } else {
   	          m = +m + 1;
   	        }
   	      }

   	      if (gtlt === '<') {
   	        pr = '-0';
   	      }

   	      ret = `${gtlt + M}.${m}.${p}${pr}`;
   	    } else if (xm) {
   	      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
   	    } else if (xp) {
   	      ret = `>=${M}.${m}.0${pr
	      } <${M}.${+m + 1}.0-0`;
   	    }

   	    debug('xRange return', ret);

   	    return ret
   	  })
   	};

   	// Because * is AND-ed with everything else in the comparator,
   	// and '' means "any version", just remove the *s entirely.
   	const replaceStars = (comp, options) => {
   	  debug('replaceStars', comp, options);
   	  // Looseness is ignored here.  star is always as loose as it gets!
   	  return comp
   	    .trim()
   	    .replace(re[t.STAR], '')
   	};

   	const replaceGTE0 = (comp, options) => {
   	  debug('replaceGTE0', comp, options);
   	  return comp
   	    .trim()
   	    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
   	};

   	// This function is passed to string.replace(re[t.HYPHENRANGE])
   	// M, m, patch, prerelease, build
   	// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
   	// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
   	// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
   	// TODO build?
   	const hyphenReplace = incPr => ($0,
   	  from, fM, fm, fp, fpr, fb,
   	  to, tM, tm, tp, tpr) => {
   	  if (isX(fM)) {
   	    from = '';
   	  } else if (isX(fm)) {
   	    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
   	  } else if (isX(fp)) {
   	    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
   	  } else if (fpr) {
   	    from = `>=${from}`;
   	  } else {
   	    from = `>=${from}${incPr ? '-0' : ''}`;
   	  }

   	  if (isX(tM)) {
   	    to = '';
   	  } else if (isX(tm)) {
   	    to = `<${+tM + 1}.0.0-0`;
   	  } else if (isX(tp)) {
   	    to = `<${tM}.${+tm + 1}.0-0`;
   	  } else if (tpr) {
   	    to = `<=${tM}.${tm}.${tp}-${tpr}`;
   	  } else if (incPr) {
   	    to = `<${tM}.${tm}.${+tp + 1}-0`;
   	  } else {
   	    to = `<=${to}`;
   	  }

   	  return `${from} ${to}`.trim()
   	};

   	const testSet = (set, version, options) => {
   	  for (let i = 0; i < set.length; i++) {
   	    if (!set[i].test(version)) {
   	      return false
   	    }
   	  }

   	  if (version.prerelease.length && !options.includePrerelease) {
   	    // Find the set of versions that are allowed to have prereleases
   	    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
   	    // That should allow `1.2.3-pr.2` to pass.
   	    // However, `1.2.4-alpha.notready` should NOT be allowed,
   	    // even though it's within the range set by the comparators.
   	    for (let i = 0; i < set.length; i++) {
   	      debug(set[i].semver);
   	      if (set[i].semver === Comparator.ANY) {
   	        continue
   	      }

   	      if (set[i].semver.prerelease.length > 0) {
   	        const allowed = set[i].semver;
   	        if (allowed.major === version.major &&
   	            allowed.minor === version.minor &&
   	            allowed.patch === version.patch) {
   	          return true
   	        }
   	      }
   	    }

   	    // Version has a -pre, but it's not one of the ones we like.
   	    return false
   	  }

   	  return true
   	};
   	return range;
   }

   var comparator;
   var hasRequiredComparator;

   function requireComparator () {
   	if (hasRequiredComparator) return comparator;
   	hasRequiredComparator = 1;
   	const ANY = Symbol('SemVer ANY');
   	// hoisted class for cyclic dependency
   	class Comparator {
   	  static get ANY () {
   	    return ANY
   	  }

   	  constructor (comp, options) {
   	    options = parseOptions(options);

   	    if (comp instanceof Comparator) {
   	      if (comp.loose === !!options.loose) {
   	        return comp
   	      } else {
   	        comp = comp.value;
   	      }
   	    }

   	    comp = comp.trim().split(/\s+/).join(' ');
   	    debug('comparator', comp, options);
   	    this.options = options;
   	    this.loose = !!options.loose;
   	    this.parse(comp);

   	    if (this.semver === ANY) {
   	      this.value = '';
   	    } else {
   	      this.value = this.operator + this.semver.version;
   	    }

   	    debug('comp', this);
   	  }

   	  parse (comp) {
   	    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
   	    const m = comp.match(r);

   	    if (!m) {
   	      throw new TypeError(`Invalid comparator: ${comp}`)
   	    }

   	    this.operator = m[1] !== undefined ? m[1] : '';
   	    if (this.operator === '=') {
   	      this.operator = '';
   	    }

   	    // if it literally is just '>' or '' then allow anything.
   	    if (!m[2]) {
   	      this.semver = ANY;
   	    } else {
   	      this.semver = new SemVer(m[2], this.options.loose);
   	    }
   	  }

   	  toString () {
   	    return this.value
   	  }

   	  test (version) {
   	    debug('Comparator.test', version, this.options.loose);

   	    if (this.semver === ANY || version === ANY) {
   	      return true
   	    }

   	    if (typeof version === 'string') {
   	      try {
   	        version = new SemVer(version, this.options);
   	      } catch (er) {
   	        return false
   	      }
   	    }

   	    return cmp(version, this.operator, this.semver, this.options)
   	  }

   	  intersects (comp, options) {
   	    if (!(comp instanceof Comparator)) {
   	      throw new TypeError('a Comparator is required')
   	    }

   	    if (this.operator === '') {
   	      if (this.value === '') {
   	        return true
   	      }
   	      return new Range(comp.value, options).test(this.value)
   	    } else if (comp.operator === '') {
   	      if (comp.value === '') {
   	        return true
   	      }
   	      return new Range(this.value, options).test(comp.semver)
   	    }

   	    options = parseOptions(options);

   	    // Special cases where nothing can possibly be lower
   	    if (options.includePrerelease &&
   	      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
   	      return false
   	    }
   	    if (!options.includePrerelease &&
   	      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
   	      return false
   	    }

   	    // Same direction increasing (> or >=)
   	    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
   	      return true
   	    }
   	    // Same direction decreasing (< or <=)
   	    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
   	      return true
   	    }
   	    // same SemVer and both sides are inclusive (<= or >=)
   	    if (
   	      (this.semver.version === comp.semver.version) &&
   	      this.operator.includes('=') && comp.operator.includes('=')) {
   	      return true
   	    }
   	    // opposite directions less than
   	    if (cmp(this.semver, '<', comp.semver, options) &&
   	      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
   	      return true
   	    }
   	    // opposite directions greater than
   	    if (cmp(this.semver, '>', comp.semver, options) &&
   	      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
   	      return true
   	    }
   	    return false
   	  }
   	}

   	comparator = Comparator;

   	const parseOptions = requireParseOptions();
   	const { safeRe: re, t } = requireRe();
   	const cmp = requireCmp();
   	const debug = requireDebug();
   	const SemVer = requireSemver$1();
   	const Range = requireRange();
   	return comparator;
   }

   var satisfies_1;
   var hasRequiredSatisfies;

   function requireSatisfies () {
   	if (hasRequiredSatisfies) return satisfies_1;
   	hasRequiredSatisfies = 1;
   	const Range = requireRange();
   	const satisfies = (version, range, options) => {
   	  try {
   	    range = new Range(range, options);
   	  } catch (er) {
   	    return false
   	  }
   	  return range.test(version)
   	};
   	satisfies_1 = satisfies;
   	return satisfies_1;
   }

   var toComparators_1;
   var hasRequiredToComparators;

   function requireToComparators () {
   	if (hasRequiredToComparators) return toComparators_1;
   	hasRequiredToComparators = 1;
   	const Range = requireRange();

   	// Mostly just for testing and legacy API reasons
   	const toComparators = (range, options) =>
   	  new Range(range, options).set
   	    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '));

   	toComparators_1 = toComparators;
   	return toComparators_1;
   }

   var maxSatisfying_1;
   var hasRequiredMaxSatisfying;

   function requireMaxSatisfying () {
   	if (hasRequiredMaxSatisfying) return maxSatisfying_1;
   	hasRequiredMaxSatisfying = 1;
   	const SemVer = requireSemver$1();
   	const Range = requireRange();

   	const maxSatisfying = (versions, range, options) => {
   	  let max = null;
   	  let maxSV = null;
   	  let rangeObj = null;
   	  try {
   	    rangeObj = new Range(range, options);
   	  } catch (er) {
   	    return null
   	  }
   	  versions.forEach((v) => {
   	    if (rangeObj.test(v)) {
   	      // satisfies(v, range, options)
   	      if (!max || maxSV.compare(v) === -1) {
   	        // compare(max, v, true)
   	        max = v;
   	        maxSV = new SemVer(max, options);
   	      }
   	    }
   	  });
   	  return max
   	};
   	maxSatisfying_1 = maxSatisfying;
   	return maxSatisfying_1;
   }

   var minSatisfying_1;
   var hasRequiredMinSatisfying;

   function requireMinSatisfying () {
   	if (hasRequiredMinSatisfying) return minSatisfying_1;
   	hasRequiredMinSatisfying = 1;
   	const SemVer = requireSemver$1();
   	const Range = requireRange();
   	const minSatisfying = (versions, range, options) => {
   	  let min = null;
   	  let minSV = null;
   	  let rangeObj = null;
   	  try {
   	    rangeObj = new Range(range, options);
   	  } catch (er) {
   	    return null
   	  }
   	  versions.forEach((v) => {
   	    if (rangeObj.test(v)) {
   	      // satisfies(v, range, options)
   	      if (!min || minSV.compare(v) === 1) {
   	        // compare(min, v, true)
   	        min = v;
   	        minSV = new SemVer(min, options);
   	      }
   	    }
   	  });
   	  return min
   	};
   	minSatisfying_1 = minSatisfying;
   	return minSatisfying_1;
   }

   var minVersion_1;
   var hasRequiredMinVersion;

   function requireMinVersion () {
   	if (hasRequiredMinVersion) return minVersion_1;
   	hasRequiredMinVersion = 1;
   	const SemVer = requireSemver$1();
   	const Range = requireRange();
   	const gt = requireGt();

   	const minVersion = (range, loose) => {
   	  range = new Range(range, loose);

   	  let minver = new SemVer('0.0.0');
   	  if (range.test(minver)) {
   	    return minver
   	  }

   	  minver = new SemVer('0.0.0-0');
   	  if (range.test(minver)) {
   	    return minver
   	  }

   	  minver = null;
   	  for (let i = 0; i < range.set.length; ++i) {
   	    const comparators = range.set[i];

   	    let setMin = null;
   	    comparators.forEach((comparator) => {
   	      // Clone to avoid manipulating the comparator's semver object.
   	      const compver = new SemVer(comparator.semver.version);
   	      switch (comparator.operator) {
   	        case '>':
   	          if (compver.prerelease.length === 0) {
   	            compver.patch++;
   	          } else {
   	            compver.prerelease.push(0);
   	          }
   	          compver.raw = compver.format();
   	          /* fallthrough */
   	        case '':
   	        case '>=':
   	          if (!setMin || gt(compver, setMin)) {
   	            setMin = compver;
   	          }
   	          break
   	        case '<':
   	        case '<=':
   	          /* Ignore maximum versions */
   	          break
   	        /* istanbul ignore next */
   	        default:
   	          throw new Error(`Unexpected operation: ${comparator.operator}`)
   	      }
   	    });
   	    if (setMin && (!minver || gt(minver, setMin))) {
   	      minver = setMin;
   	    }
   	  }

   	  if (minver && range.test(minver)) {
   	    return minver
   	  }

   	  return null
   	};
   	minVersion_1 = minVersion;
   	return minVersion_1;
   }

   var valid;
   var hasRequiredValid;

   function requireValid () {
   	if (hasRequiredValid) return valid;
   	hasRequiredValid = 1;
   	const Range = requireRange();
   	const validRange = (range, options) => {
   	  try {
   	    // Return '*' instead of '' so that truthiness works.
   	    // This will throw if it's invalid anyway
   	    return new Range(range, options).range || '*'
   	  } catch (er) {
   	    return null
   	  }
   	};
   	valid = validRange;
   	return valid;
   }

   var outside_1;
   var hasRequiredOutside;

   function requireOutside () {
   	if (hasRequiredOutside) return outside_1;
   	hasRequiredOutside = 1;
   	const SemVer = requireSemver$1();
   	const Comparator = requireComparator();
   	const { ANY } = Comparator;
   	const Range = requireRange();
   	const satisfies = requireSatisfies();
   	const gt = requireGt();
   	const lt = requireLt();
   	const lte = requireLte();
   	const gte = requireGte();

   	const outside = (version, range, hilo, options) => {
   	  version = new SemVer(version, options);
   	  range = new Range(range, options);

   	  let gtfn, ltefn, ltfn, comp, ecomp;
   	  switch (hilo) {
   	    case '>':
   	      gtfn = gt;
   	      ltefn = lte;
   	      ltfn = lt;
   	      comp = '>';
   	      ecomp = '>=';
   	      break
   	    case '<':
   	      gtfn = lt;
   	      ltefn = gte;
   	      ltfn = gt;
   	      comp = '<';
   	      ecomp = '<=';
   	      break
   	    default:
   	      throw new TypeError('Must provide a hilo val of "<" or ">"')
   	  }

   	  // If it satisfies the range it is not outside
   	  if (satisfies(version, range, options)) {
   	    return false
   	  }

   	  // From now on, variable terms are as if we're in "gtr" mode.
   	  // but note that everything is flipped for the "ltr" function.

   	  for (let i = 0; i < range.set.length; ++i) {
   	    const comparators = range.set[i];

   	    let high = null;
   	    let low = null;

   	    comparators.forEach((comparator) => {
   	      if (comparator.semver === ANY) {
   	        comparator = new Comparator('>=0.0.0');
   	      }
   	      high = high || comparator;
   	      low = low || comparator;
   	      if (gtfn(comparator.semver, high.semver, options)) {
   	        high = comparator;
   	      } else if (ltfn(comparator.semver, low.semver, options)) {
   	        low = comparator;
   	      }
   	    });

   	    // If the edge version comparator has a operator then our version
   	    // isn't outside it
   	    if (high.operator === comp || high.operator === ecomp) {
   	      return false
   	    }

   	    // If the lowest version comparator has an operator and our version
   	    // is less than it then it isn't higher than the range
   	    if ((!low.operator || low.operator === comp) &&
   	        ltefn(version, low.semver)) {
   	      return false
   	    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
   	      return false
   	    }
   	  }
   	  return true
   	};

   	outside_1 = outside;
   	return outside_1;
   }

   var gtr_1;
   var hasRequiredGtr;

   function requireGtr () {
   	if (hasRequiredGtr) return gtr_1;
   	hasRequiredGtr = 1;
   	// Determine if version is greater than all the versions possible in the range.
   	const outside = requireOutside();
   	const gtr = (version, range, options) => outside(version, range, '>', options);
   	gtr_1 = gtr;
   	return gtr_1;
   }

   var ltr_1;
   var hasRequiredLtr;

   function requireLtr () {
   	if (hasRequiredLtr) return ltr_1;
   	hasRequiredLtr = 1;
   	const outside = requireOutside();
   	// Determine if version is less than all the versions possible in the range
   	const ltr = (version, range, options) => outside(version, range, '<', options);
   	ltr_1 = ltr;
   	return ltr_1;
   }

   var intersects_1;
   var hasRequiredIntersects;

   function requireIntersects () {
   	if (hasRequiredIntersects) return intersects_1;
   	hasRequiredIntersects = 1;
   	const Range = requireRange();
   	const intersects = (r1, r2, options) => {
   	  r1 = new Range(r1, options);
   	  r2 = new Range(r2, options);
   	  return r1.intersects(r2, options)
   	};
   	intersects_1 = intersects;
   	return intersects_1;
   }

   var simplify;
   var hasRequiredSimplify;

   function requireSimplify () {
   	if (hasRequiredSimplify) return simplify;
   	hasRequiredSimplify = 1;
   	// given a set of versions and a range, create a "simplified" range
   	// that includes the same versions that the original range does
   	// If the original range is shorter than the simplified one, return that.
   	const satisfies = requireSatisfies();
   	const compare = requireCompare();
   	simplify = (versions, range, options) => {
   	  const set = [];
   	  let first = null;
   	  let prev = null;
   	  const v = versions.sort((a, b) => compare(a, b, options));
   	  for (const version of v) {
   	    const included = satisfies(version, range, options);
   	    if (included) {
   	      prev = version;
   	      if (!first) {
   	        first = version;
   	      }
   	    } else {
   	      if (prev) {
   	        set.push([first, prev]);
   	      }
   	      prev = null;
   	      first = null;
   	    }
   	  }
   	  if (first) {
   	    set.push([first, null]);
   	  }

   	  const ranges = [];
   	  for (const [min, max] of set) {
   	    if (min === max) {
   	      ranges.push(min);
   	    } else if (!max && min === v[0]) {
   	      ranges.push('*');
   	    } else if (!max) {
   	      ranges.push(`>=${min}`);
   	    } else if (min === v[0]) {
   	      ranges.push(`<=${max}`);
   	    } else {
   	      ranges.push(`${min} - ${max}`);
   	    }
   	  }
   	  const simplified = ranges.join(' || ');
   	  const original = typeof range.raw === 'string' ? range.raw : String(range);
   	  return simplified.length < original.length ? simplified : range
   	};
   	return simplify;
   }

   var subset_1;
   var hasRequiredSubset;

   function requireSubset () {
   	if (hasRequiredSubset) return subset_1;
   	hasRequiredSubset = 1;
   	const Range = requireRange();
   	const Comparator = requireComparator();
   	const { ANY } = Comparator;
   	const satisfies = requireSatisfies();
   	const compare = requireCompare();

   	// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
   	// - Every simple range `r1, r2, ...` is a null set, OR
   	// - Every simple range `r1, r2, ...` which is not a null set is a subset of
   	//   some `R1, R2, ...`
   	//
   	// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
   	// - If c is only the ANY comparator
   	//   - If C is only the ANY comparator, return true
   	//   - Else if in prerelease mode, return false
   	//   - else replace c with `[>=0.0.0]`
   	// - If C is only the ANY comparator
   	//   - if in prerelease mode, return true
   	//   - else replace C with `[>=0.0.0]`
   	// - Let EQ be the set of = comparators in c
   	// - If EQ is more than one, return true (null set)
   	// - Let GT be the highest > or >= comparator in c
   	// - Let LT be the lowest < or <= comparator in c
   	// - If GT and LT, and GT.semver > LT.semver, return true (null set)
   	// - If any C is a = range, and GT or LT are set, return false
   	// - If EQ
   	//   - If GT, and EQ does not satisfy GT, return true (null set)
   	//   - If LT, and EQ does not satisfy LT, return true (null set)
   	//   - If EQ satisfies every C, return true
   	//   - Else return false
   	// - If GT
   	//   - If GT.semver is lower than any > or >= comp in C, return false
   	//   - If GT is >=, and GT.semver does not satisfy every C, return false
   	//   - If GT.semver has a prerelease, and not in prerelease mode
   	//     - If no C has a prerelease and the GT.semver tuple, return false
   	// - If LT
   	//   - If LT.semver is greater than any < or <= comp in C, return false
   	//   - If LT is <=, and LT.semver does not satisfy every C, return false
   	//   - If GT.semver has a prerelease, and not in prerelease mode
   	//     - If no C has a prerelease and the LT.semver tuple, return false
   	// - Else return true

   	const subset = (sub, dom, options = {}) => {
   	  if (sub === dom) {
   	    return true
   	  }

   	  sub = new Range(sub, options);
   	  dom = new Range(dom, options);
   	  let sawNonNull = false;

   	  OUTER: for (const simpleSub of sub.set) {
   	    for (const simpleDom of dom.set) {
   	      const isSub = simpleSubset(simpleSub, simpleDom, options);
   	      sawNonNull = sawNonNull || isSub !== null;
   	      if (isSub) {
   	        continue OUTER
   	      }
   	    }
   	    // the null set is a subset of everything, but null simple ranges in
   	    // a complex range should be ignored.  so if we saw a non-null range,
   	    // then we know this isn't a subset, but if EVERY simple range was null,
   	    // then it is a subset.
   	    if (sawNonNull) {
   	      return false
   	    }
   	  }
   	  return true
   	};

   	const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')];
   	const minimumVersion = [new Comparator('>=0.0.0')];

   	const simpleSubset = (sub, dom, options) => {
   	  if (sub === dom) {
   	    return true
   	  }

   	  if (sub.length === 1 && sub[0].semver === ANY) {
   	    if (dom.length === 1 && dom[0].semver === ANY) {
   	      return true
   	    } else if (options.includePrerelease) {
   	      sub = minimumVersionWithPreRelease;
   	    } else {
   	      sub = minimumVersion;
   	    }
   	  }

   	  if (dom.length === 1 && dom[0].semver === ANY) {
   	    if (options.includePrerelease) {
   	      return true
   	    } else {
   	      dom = minimumVersion;
   	    }
   	  }

   	  const eqSet = new Set();
   	  let gt, lt;
   	  for (const c of sub) {
   	    if (c.operator === '>' || c.operator === '>=') {
   	      gt = higherGT(gt, c, options);
   	    } else if (c.operator === '<' || c.operator === '<=') {
   	      lt = lowerLT(lt, c, options);
   	    } else {
   	      eqSet.add(c.semver);
   	    }
   	  }

   	  if (eqSet.size > 1) {
   	    return null
   	  }

   	  let gtltComp;
   	  if (gt && lt) {
   	    gtltComp = compare(gt.semver, lt.semver, options);
   	    if (gtltComp > 0) {
   	      return null
   	    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
   	      return null
   	    }
   	  }

   	  // will iterate one or zero times
   	  for (const eq of eqSet) {
   	    if (gt && !satisfies(eq, String(gt), options)) {
   	      return null
   	    }

   	    if (lt && !satisfies(eq, String(lt), options)) {
   	      return null
   	    }

   	    for (const c of dom) {
   	      if (!satisfies(eq, String(c), options)) {
   	        return false
   	      }
   	    }

   	    return true
   	  }

   	  let higher, lower;
   	  let hasDomLT, hasDomGT;
   	  // if the subset has a prerelease, we need a comparator in the superset
   	  // with the same tuple and a prerelease, or it's not a subset
   	  let needDomLTPre = lt &&
   	    !options.includePrerelease &&
   	    lt.semver.prerelease.length ? lt.semver : false;
   	  let needDomGTPre = gt &&
   	    !options.includePrerelease &&
   	    gt.semver.prerelease.length ? gt.semver : false;
   	  // exception: <1.2.3-0 is the same as <1.2.3
   	  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
   	      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
   	    needDomLTPre = false;
   	  }

   	  for (const c of dom) {
   	    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
   	    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
   	    if (gt) {
   	      if (needDomGTPre) {
   	        if (c.semver.prerelease && c.semver.prerelease.length &&
   	            c.semver.major === needDomGTPre.major &&
   	            c.semver.minor === needDomGTPre.minor &&
   	            c.semver.patch === needDomGTPre.patch) {
   	          needDomGTPre = false;
   	        }
   	      }
   	      if (c.operator === '>' || c.operator === '>=') {
   	        higher = higherGT(gt, c, options);
   	        if (higher === c && higher !== gt) {
   	          return false
   	        }
   	      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
   	        return false
   	      }
   	    }
   	    if (lt) {
   	      if (needDomLTPre) {
   	        if (c.semver.prerelease && c.semver.prerelease.length &&
   	            c.semver.major === needDomLTPre.major &&
   	            c.semver.minor === needDomLTPre.minor &&
   	            c.semver.patch === needDomLTPre.patch) {
   	          needDomLTPre = false;
   	        }
   	      }
   	      if (c.operator === '<' || c.operator === '<=') {
   	        lower = lowerLT(lt, c, options);
   	        if (lower === c && lower !== lt) {
   	          return false
   	        }
   	      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
   	        return false
   	      }
   	    }
   	    if (!c.operator && (lt || gt) && gtltComp !== 0) {
   	      return false
   	    }
   	  }

   	  // if there was a < or >, and nothing in the dom, then must be false
   	  // UNLESS it was limited by another range in the other direction.
   	  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
   	  if (gt && hasDomLT && !lt && gtltComp !== 0) {
   	    return false
   	  }

   	  if (lt && hasDomGT && !gt && gtltComp !== 0) {
   	    return false
   	  }

   	  // we needed a prerelease range in a specific tuple, but didn't get one
   	  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
   	  // because it includes prereleases in the 1.2.3 tuple
   	  if (needDomGTPre || needDomLTPre) {
   	    return false
   	  }

   	  return true
   	};

   	// >=1.2.3 is lower than >1.2.3
   	const higherGT = (a, b, options) => {
   	  if (!a) {
   	    return b
   	  }
   	  const comp = compare(a.semver, b.semver, options);
   	  return comp > 0 ? a
   	    : comp < 0 ? b
   	    : b.operator === '>' && a.operator === '>=' ? b
   	    : a
   	};

   	// <=1.2.3 is higher than <1.2.3
   	const lowerLT = (a, b, options) => {
   	  if (!a) {
   	    return b
   	  }
   	  const comp = compare(a.semver, b.semver, options);
   	  return comp < 0 ? a
   	    : comp > 0 ? b
   	    : b.operator === '<' && a.operator === '<=' ? b
   	    : a
   	};

   	subset_1 = subset;
   	return subset_1;
   }

   var semver;
   var hasRequiredSemver;

   function requireSemver () {
   	if (hasRequiredSemver) return semver;
   	hasRequiredSemver = 1;
   	// just pre-load all the stuff that index.js lazily exports
   	const internalRe = requireRe();
   	const constants = requireConstants();
   	const SemVer = requireSemver$1();
   	const identifiers = requireIdentifiers();
   	const parse = requireParse();
   	const valid = requireValid$1();
   	const clean = requireClean();
   	const inc = requireInc();
   	const diff = requireDiff();
   	const major = requireMajor();
   	const minor = requireMinor();
   	const patch = requirePatch();
   	const prerelease = requirePrerelease();
   	const compare = requireCompare();
   	const rcompare = requireRcompare();
   	const compareLoose = requireCompareLoose();
   	const compareBuild = requireCompareBuild();
   	const sort = requireSort();
   	const rsort = requireRsort();
   	const gt = requireGt();
   	const lt = requireLt();
   	const eq = requireEq();
   	const neq = requireNeq();
   	const gte = requireGte();
   	const lte = requireLte();
   	const cmp = requireCmp();
   	const coerce = requireCoerce();
   	const Comparator = requireComparator();
   	const Range = requireRange();
   	const satisfies = requireSatisfies();
   	const toComparators = requireToComparators();
   	const maxSatisfying = requireMaxSatisfying();
   	const minSatisfying = requireMinSatisfying();
   	const minVersion = requireMinVersion();
   	const validRange = requireValid();
   	const outside = requireOutside();
   	const gtr = requireGtr();
   	const ltr = requireLtr();
   	const intersects = requireIntersects();
   	const simplifyRange = requireSimplify();
   	const subset = requireSubset();
   	semver = {
   	  parse,
   	  valid,
   	  clean,
   	  inc,
   	  diff,
   	  major,
   	  minor,
   	  patch,
   	  prerelease,
   	  compare,
   	  rcompare,
   	  compareLoose,
   	  compareBuild,
   	  sort,
   	  rsort,
   	  gt,
   	  lt,
   	  eq,
   	  neq,
   	  gte,
   	  lte,
   	  cmp,
   	  coerce,
   	  Comparator,
   	  Range,
   	  satisfies,
   	  toComparators,
   	  maxSatisfying,
   	  minSatisfying,
   	  minVersion,
   	  validRange,
   	  outside,
   	  gtr,
   	  ltr,
   	  intersects,
   	  simplifyRange,
   	  subset,
   	  SemVer,
   	  re: internalRe.re,
   	  src: internalRe.src,
   	  tokens: internalRe.t,
   	  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
   	  RELEASE_TYPES: constants.RELEASE_TYPES,
   	  compareIdentifiers: identifiers.compareIdentifiers,
   	  rcompareIdentifiers: identifiers.rcompareIdentifiers,
   	};
   	return semver;
   }

   var asymmetricKeyDetailsSupported;
   var hasRequiredAsymmetricKeyDetailsSupported;

   function requireAsymmetricKeyDetailsSupported () {
   	if (hasRequiredAsymmetricKeyDetailsSupported) return asymmetricKeyDetailsSupported;
   	hasRequiredAsymmetricKeyDetailsSupported = 1;
   	const semver = requireSemver();

   	asymmetricKeyDetailsSupported = semver.satisfies(process.version, '>=15.7.0');
   	return asymmetricKeyDetailsSupported;
   }

   var rsaPssKeyDetailsSupported;
   var hasRequiredRsaPssKeyDetailsSupported;

   function requireRsaPssKeyDetailsSupported () {
   	if (hasRequiredRsaPssKeyDetailsSupported) return rsaPssKeyDetailsSupported;
   	hasRequiredRsaPssKeyDetailsSupported = 1;
   	const semver = requireSemver();

   	rsaPssKeyDetailsSupported = semver.satisfies(process.version, '>=16.9.0');
   	return rsaPssKeyDetailsSupported;
   }

   var validateAsymmetricKey;
   var hasRequiredValidateAsymmetricKey;

   function requireValidateAsymmetricKey () {
   	if (hasRequiredValidateAsymmetricKey) return validateAsymmetricKey;
   	hasRequiredValidateAsymmetricKey = 1;
   	const ASYMMETRIC_KEY_DETAILS_SUPPORTED = requireAsymmetricKeyDetailsSupported();
   	const RSA_PSS_KEY_DETAILS_SUPPORTED = requireRsaPssKeyDetailsSupported();

   	const allowedAlgorithmsForKeys = {
   	  'ec': ['ES256', 'ES384', 'ES512'],
   	  'rsa': ['RS256', 'PS256', 'RS384', 'PS384', 'RS512', 'PS512'],
   	  'rsa-pss': ['PS256', 'PS384', 'PS512']
   	};

   	const allowedCurves = {
   	  ES256: 'prime256v1',
   	  ES384: 'secp384r1',
   	  ES512: 'secp521r1',
   	};

   	validateAsymmetricKey = function(algorithm, key) {
   	  if (!algorithm || !key) return;

   	  const keyType = key.asymmetricKeyType;
   	  if (!keyType) return;

   	  const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];

   	  if (!allowedAlgorithms) {
   	    throw new Error(`Unknown key type "${keyType}".`);
   	  }

   	  if (!allowedAlgorithms.includes(algorithm)) {
   	    throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(', ')}.`)
   	  }

   	  /*
   	   * Ignore the next block from test coverage because it gets executed
   	   * conditionally depending on the Node version. Not ignoring it would
   	   * prevent us from reaching the target % of coverage for versions of
   	   * Node under 15.7.0.
   	   */
   	  /* istanbul ignore next */
   	  if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
   	    switch (keyType) {
   	    case 'ec':
   	      const keyCurve = key.asymmetricKeyDetails.namedCurve;
   	      const allowedCurve = allowedCurves[algorithm];

   	      if (keyCurve !== allowedCurve) {
   	        throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
   	      }
   	      break;

   	    case 'rsa-pss':
   	      if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
   	        const length = parseInt(algorithm.slice(-3), 10);
   	        const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;

   	        if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
   	          throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
   	        }

   	        if (saltLength !== undefined && saltLength > length >> 3) {
   	          throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`)
   	        }
   	      }
   	      break;
   	    }
   	  }
   	};
   	return validateAsymmetricKey;
   }

   var psSupported;
   var hasRequiredPsSupported;

   function requirePsSupported () {
   	if (hasRequiredPsSupported) return psSupported;
   	hasRequiredPsSupported = 1;
   	var semver = requireSemver();

   	psSupported = semver.satisfies(process.version, '^6.12.0 || >=8.0.0');
   	return psSupported;
   }

   var verify;
   var hasRequiredVerify;

   function requireVerify () {
   	if (hasRequiredVerify) return verify;
   	hasRequiredVerify = 1;
   	const JsonWebTokenError = requireJsonWebTokenError();
   	const NotBeforeError = requireNotBeforeError();
   	const TokenExpiredError = requireTokenExpiredError();
   	const decode = requireDecode();
   	const timespan = requireTimespan();
   	const validateAsymmetricKey = requireValidateAsymmetricKey();
   	const PS_SUPPORTED = requirePsSupported();
   	const jws = requireJws();
   	const {KeyObject, createSecretKey, createPublicKey} = require$$1;

   	const PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512'];
   	const EC_KEY_ALGS = ['ES256', 'ES384', 'ES512'];
   	const RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];
   	const HS_ALGS = ['HS256', 'HS384', 'HS512'];

   	if (PS_SUPPORTED) {
   	  PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');
   	  RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');
   	}

   	verify = function (jwtString, secretOrPublicKey, options, callback) {
   	  if ((typeof options === 'function') && !callback) {
   	    callback = options;
   	    options = {};
   	  }

   	  if (!options) {
   	    options = {};
   	  }

   	  //clone this object since we are going to mutate it.
   	  options = Object.assign({}, options);

   	  let done;

   	  if (callback) {
   	    done = callback;
   	  } else {
   	    done = function(err, data) {
   	      if (err) throw err;
   	      return data;
   	    };
   	  }

   	  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {
   	    return done(new JsonWebTokenError('clockTimestamp must be a number'));
   	  }

   	  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {
   	    return done(new JsonWebTokenError('nonce must be a non-empty string'));
   	  }

   	  if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== 'boolean') {
   	    return done(new JsonWebTokenError('allowInvalidAsymmetricKeyTypes must be a boolean'));
   	  }

   	  const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);

   	  if (!jwtString){
   	    return done(new JsonWebTokenError('jwt must be provided'));
   	  }

   	  if (typeof jwtString !== 'string') {
   	    return done(new JsonWebTokenError('jwt must be a string'));
   	  }

   	  const parts = jwtString.split('.');

   	  if (parts.length !== 3){
   	    return done(new JsonWebTokenError('jwt malformed'));
   	  }

   	  let decodedToken;

   	  try {
   	    decodedToken = decode(jwtString, { complete: true });
   	  } catch(err) {
   	    return done(err);
   	  }

   	  if (!decodedToken) {
   	    return done(new JsonWebTokenError('invalid token'));
   	  }

   	  const header = decodedToken.header;
   	  let getSecret;

   	  if(typeof secretOrPublicKey === 'function') {
   	    if(!callback) {
   	      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));
   	    }

   	    getSecret = secretOrPublicKey;
   	  }
   	  else {
   	    getSecret = function(header, secretCallback) {
   	      return secretCallback(null, secretOrPublicKey);
   	    };
   	  }

   	  return getSecret(header, function(err, secretOrPublicKey) {
   	    if(err) {
   	      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));
   	    }

   	    const hasSignature = parts[2].trim() !== '';

   	    if (!hasSignature && secretOrPublicKey){
   	      return done(new JsonWebTokenError('jwt signature is required'));
   	    }

   	    if (hasSignature && !secretOrPublicKey) {
   	      return done(new JsonWebTokenError('secret or public key must be provided'));
   	    }

   	    if (!hasSignature && !options.algorithms) {
   	      return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
   	    }

   	    if (secretOrPublicKey != null && !(secretOrPublicKey instanceof KeyObject)) {
   	      try {
   	        secretOrPublicKey = createPublicKey(secretOrPublicKey);
   	      } catch (_) {
   	        try {
   	          secretOrPublicKey = createSecretKey(typeof secretOrPublicKey === 'string' ? Buffer.from(secretOrPublicKey) : secretOrPublicKey);
   	        } catch (_) {
   	          return done(new JsonWebTokenError('secretOrPublicKey is not valid key material'))
   	        }
   	      }
   	    }

   	    if (!options.algorithms) {
   	      if (secretOrPublicKey.type === 'secret') {
   	        options.algorithms = HS_ALGS;
   	      } else if (['rsa', 'rsa-pss'].includes(secretOrPublicKey.asymmetricKeyType)) {
   	        options.algorithms = RSA_KEY_ALGS;
   	      } else if (secretOrPublicKey.asymmetricKeyType === 'ec') {
   	        options.algorithms = EC_KEY_ALGS;
   	      } else {
   	        options.algorithms = PUB_KEY_ALGS;
   	      }
   	    }

   	    if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
   	      return done(new JsonWebTokenError('invalid algorithm'));
   	    }

   	    if (header.alg.startsWith('HS') && secretOrPublicKey.type !== 'secret') {
   	      return done(new JsonWebTokenError((`secretOrPublicKey must be a symmetric key when using ${header.alg}`)))
   	    } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey.type !== 'public') {
   	      return done(new JsonWebTokenError((`secretOrPublicKey must be an asymmetric key when using ${header.alg}`)))
   	    }

   	    if (!options.allowInvalidAsymmetricKeyTypes) {
   	      try {
   	        validateAsymmetricKey(header.alg, secretOrPublicKey);
   	      } catch (e) {
   	        return done(e);
   	      }
   	    }

   	    let valid;

   	    try {
   	      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);
   	    } catch (e) {
   	      return done(e);
   	    }

   	    if (!valid) {
   	      return done(new JsonWebTokenError('invalid signature'));
   	    }

   	    const payload = decodedToken.payload;

   	    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {
   	      if (typeof payload.nbf !== 'number') {
   	        return done(new JsonWebTokenError('invalid nbf value'));
   	      }
   	      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
   	        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));
   	      }
   	    }

   	    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {
   	      if (typeof payload.exp !== 'number') {
   	        return done(new JsonWebTokenError('invalid exp value'));
   	      }
   	      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
   	        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));
   	      }
   	    }

   	    if (options.audience) {
   	      const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
   	      const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];

   	      const match = target.some(function (targetAudience) {
   	        return audiences.some(function (audience) {
   	          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
   	        });
   	      });

   	      if (!match) {
   	        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));
   	      }
   	    }

   	    if (options.issuer) {
   	      const invalid_issuer =
   	              (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||
   	              (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);

   	      if (invalid_issuer) {
   	        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));
   	      }
   	    }

   	    if (options.subject) {
   	      if (payload.sub !== options.subject) {
   	        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));
   	      }
   	    }

   	    if (options.jwtid) {
   	      if (payload.jti !== options.jwtid) {
   	        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));
   	      }
   	    }

   	    if (options.nonce) {
   	      if (payload.nonce !== options.nonce) {
   	        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));
   	      }
   	    }

   	    if (options.maxAge) {
   	      if (typeof payload.iat !== 'number') {
   	        return done(new JsonWebTokenError('iat required when maxAge is specified'));
   	      }

   	      const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
   	      if (typeof maxAgeTimestamp === 'undefined') {
   	        return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
   	      }
   	      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
   	        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));
   	      }
   	    }

   	    if (options.complete === true) {
   	      const signature = decodedToken.signature;

   	      return done(null, {
   	        header: header,
   	        payload: payload,
   	        signature: signature
   	      });
   	    }

   	    return done(null, payload);
   	  });
   	};
   	return verify;
   }

   /**
    * lodash (Custom Build) <https://lodash.com/>
    * Build: `lodash modularize exports="npm" -o ./`
    * Copyright jQuery Foundation and other contributors <https://jquery.org/>
    * Released under MIT license <https://lodash.com/license>
    * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
    * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    */

   var lodash_includes;
   var hasRequiredLodash_includes;

   function requireLodash_includes () {
   	if (hasRequiredLodash_includes) return lodash_includes;
   	hasRequiredLodash_includes = 1;
   	/** Used as references for various `Number` constants. */
   	var INFINITY = 1 / 0,
   	    MAX_SAFE_INTEGER = 9007199254740991,
   	    MAX_INTEGER = 1.7976931348623157e+308,
   	    NAN = 0 / 0;

   	/** `Object#toString` result references. */
   	var argsTag = '[object Arguments]',
   	    funcTag = '[object Function]',
   	    genTag = '[object GeneratorFunction]',
   	    stringTag = '[object String]',
   	    symbolTag = '[object Symbol]';

   	/** Used to match leading and trailing whitespace. */
   	var reTrim = /^\s+|\s+$/g;

   	/** Used to detect bad signed hexadecimal string values. */
   	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

   	/** Used to detect binary string values. */
   	var reIsBinary = /^0b[01]+$/i;

   	/** Used to detect octal string values. */
   	var reIsOctal = /^0o[0-7]+$/i;

   	/** Used to detect unsigned integer values. */
   	var reIsUint = /^(?:0|[1-9]\d*)$/;

   	/** Built-in method references without a dependency on `root`. */
   	var freeParseInt = parseInt;

   	/**
   	 * A specialized version of `_.map` for arrays without support for iteratee
   	 * shorthands.
   	 *
   	 * @private
   	 * @param {Array} [array] The array to iterate over.
   	 * @param {Function} iteratee The function invoked per iteration.
   	 * @returns {Array} Returns the new mapped array.
   	 */
   	function arrayMap(array, iteratee) {
   	  var index = -1,
   	      length = array ? array.length : 0,
   	      result = Array(length);

   	  while (++index < length) {
   	    result[index] = iteratee(array[index], index, array);
   	  }
   	  return result;
   	}

   	/**
   	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
   	 * support for iteratee shorthands.
   	 *
   	 * @private
   	 * @param {Array} array The array to inspect.
   	 * @param {Function} predicate The function invoked per iteration.
   	 * @param {number} fromIndex The index to search from.
   	 * @param {boolean} [fromRight] Specify iterating from right to left.
   	 * @returns {number} Returns the index of the matched value, else `-1`.
   	 */
   	function baseFindIndex(array, predicate, fromIndex, fromRight) {
   	  var length = array.length,
   	      index = fromIndex + (-1);

   	  while ((++index < length)) {
   	    if (predicate(array[index], index, array)) {
   	      return index;
   	    }
   	  }
   	  return -1;
   	}

   	/**
   	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   	 *
   	 * @private
   	 * @param {Array} array The array to inspect.
   	 * @param {*} value The value to search for.
   	 * @param {number} fromIndex The index to search from.
   	 * @returns {number} Returns the index of the matched value, else `-1`.
   	 */
   	function baseIndexOf(array, value, fromIndex) {
   	  if (value !== value) {
   	    return baseFindIndex(array, baseIsNaN, fromIndex);
   	  }
   	  var index = fromIndex - 1,
   	      length = array.length;

   	  while (++index < length) {
   	    if (array[index] === value) {
   	      return index;
   	    }
   	  }
   	  return -1;
   	}

   	/**
   	 * The base implementation of `_.isNaN` without support for number objects.
   	 *
   	 * @private
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   	 */
   	function baseIsNaN(value) {
   	  return value !== value;
   	}

   	/**
   	 * The base implementation of `_.times` without support for iteratee shorthands
   	 * or max array length checks.
   	 *
   	 * @private
   	 * @param {number} n The number of times to invoke `iteratee`.
   	 * @param {Function} iteratee The function invoked per iteration.
   	 * @returns {Array} Returns the array of results.
   	 */
   	function baseTimes(n, iteratee) {
   	  var index = -1,
   	      result = Array(n);

   	  while (++index < n) {
   	    result[index] = iteratee(index);
   	  }
   	  return result;
   	}

   	/**
   	 * The base implementation of `_.values` and `_.valuesIn` which creates an
   	 * array of `object` property values corresponding to the property names
   	 * of `props`.
   	 *
   	 * @private
   	 * @param {Object} object The object to query.
   	 * @param {Array} props The property names to get values for.
   	 * @returns {Object} Returns the array of property values.
   	 */
   	function baseValues(object, props) {
   	  return arrayMap(props, function(key) {
   	    return object[key];
   	  });
   	}

   	/**
   	 * Creates a unary function that invokes `func` with its argument transformed.
   	 *
   	 * @private
   	 * @param {Function} func The function to wrap.
   	 * @param {Function} transform The argument transform.
   	 * @returns {Function} Returns the new function.
   	 */
   	function overArg(func, transform) {
   	  return function(arg) {
   	    return func(transform(arg));
   	  };
   	}

   	/** Used for built-in method references. */
   	var objectProto = Object.prototype;

   	/** Used to check objects for own properties. */
   	var hasOwnProperty = objectProto.hasOwnProperty;

   	/**
   	 * Used to resolve the
   	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   	 * of values.
   	 */
   	var objectToString = objectProto.toString;

   	/** Built-in value references. */
   	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

   	/* Built-in method references for those with the same name as other `lodash` methods. */
   	var nativeKeys = overArg(Object.keys, Object),
   	    nativeMax = Math.max;

   	/**
   	 * Creates an array of the enumerable property names of the array-like `value`.
   	 *
   	 * @private
   	 * @param {*} value The value to query.
   	 * @param {boolean} inherited Specify returning inherited property names.
   	 * @returns {Array} Returns the array of property names.
   	 */
   	function arrayLikeKeys(value, inherited) {
   	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
   	  // Safari 9 makes `arguments.length` enumerable in strict mode.
   	  var result = (isArray(value) || isArguments(value))
   	    ? baseTimes(value.length, String)
   	    : [];

   	  var length = result.length,
   	      skipIndexes = !!length;

   	  for (var key in value) {
   	    if ((hasOwnProperty.call(value, key)) &&
   	        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
   	      result.push(key);
   	    }
   	  }
   	  return result;
   	}

   	/**
   	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   	 *
   	 * @private
   	 * @param {Object} object The object to query.
   	 * @returns {Array} Returns the array of property names.
   	 */
   	function baseKeys(object) {
   	  if (!isPrototype(object)) {
   	    return nativeKeys(object);
   	  }
   	  var result = [];
   	  for (var key in Object(object)) {
   	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
   	      result.push(key);
   	    }
   	  }
   	  return result;
   	}

   	/**
   	 * Checks if `value` is a valid array-like index.
   	 *
   	 * @private
   	 * @param {*} value The value to check.
   	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   	 */
   	function isIndex(value, length) {
   	  length = length == null ? MAX_SAFE_INTEGER : length;
   	  return !!length &&
   	    (typeof value == 'number' || reIsUint.test(value)) &&
   	    (value > -1 && value % 1 == 0 && value < length);
   	}

   	/**
   	 * Checks if `value` is likely a prototype object.
   	 *
   	 * @private
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   	 */
   	function isPrototype(value) {
   	  var Ctor = value && value.constructor,
   	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

   	  return value === proto;
   	}

   	/**
   	 * Checks if `value` is in `collection`. If `collection` is a string, it's
   	 * checked for a substring of `value`, otherwise
   	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   	 * is used for equality comparisons. If `fromIndex` is negative, it's used as
   	 * the offset from the end of `collection`.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 0.1.0
   	 * @category Collection
   	 * @param {Array|Object|string} collection The collection to inspect.
   	 * @param {*} value The value to search for.
   	 * @param {number} [fromIndex=0] The index to search from.
   	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
   	 * @returns {boolean} Returns `true` if `value` is found, else `false`.
   	 * @example
   	 *
   	 * _.includes([1, 2, 3], 1);
   	 * // => true
   	 *
   	 * _.includes([1, 2, 3], 1, 2);
   	 * // => false
   	 *
   	 * _.includes({ 'a': 1, 'b': 2 }, 1);
   	 * // => true
   	 *
   	 * _.includes('abcd', 'bc');
   	 * // => true
   	 */
   	function includes(collection, value, fromIndex, guard) {
   	  collection = isArrayLike(collection) ? collection : values(collection);
   	  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

   	  var length = collection.length;
   	  if (fromIndex < 0) {
   	    fromIndex = nativeMax(length + fromIndex, 0);
   	  }
   	  return isString(collection)
   	    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
   	    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
   	}

   	/**
   	 * Checks if `value` is likely an `arguments` object.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 0.1.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   	 *  else `false`.
   	 * @example
   	 *
   	 * _.isArguments(function() { return arguments; }());
   	 * // => true
   	 *
   	 * _.isArguments([1, 2, 3]);
   	 * // => false
   	 */
   	function isArguments(value) {
   	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
   	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
   	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
   	}

   	/**
   	 * Checks if `value` is classified as an `Array` object.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 0.1.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   	 * @example
   	 *
   	 * _.isArray([1, 2, 3]);
   	 * // => true
   	 *
   	 * _.isArray(document.body.children);
   	 * // => false
   	 *
   	 * _.isArray('abc');
   	 * // => false
   	 *
   	 * _.isArray(_.noop);
   	 * // => false
   	 */
   	var isArray = Array.isArray;

   	/**
   	 * Checks if `value` is array-like. A value is considered array-like if it's
   	 * not a function and has a `value.length` that's an integer greater than or
   	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   	 * @example
   	 *
   	 * _.isArrayLike([1, 2, 3]);
   	 * // => true
   	 *
   	 * _.isArrayLike(document.body.children);
   	 * // => true
   	 *
   	 * _.isArrayLike('abc');
   	 * // => true
   	 *
   	 * _.isArrayLike(_.noop);
   	 * // => false
   	 */
   	function isArrayLike(value) {
   	  return value != null && isLength(value.length) && !isFunction(value);
   	}

   	/**
   	 * This method is like `_.isArrayLike` except that it also checks if `value`
   	 * is an object.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is an array-like object,
   	 *  else `false`.
   	 * @example
   	 *
   	 * _.isArrayLikeObject([1, 2, 3]);
   	 * // => true
   	 *
   	 * _.isArrayLikeObject(document.body.children);
   	 * // => true
   	 *
   	 * _.isArrayLikeObject('abc');
   	 * // => false
   	 *
   	 * _.isArrayLikeObject(_.noop);
   	 * // => false
   	 */
   	function isArrayLikeObject(value) {
   	  return isObjectLike(value) && isArrayLike(value);
   	}

   	/**
   	 * Checks if `value` is classified as a `Function` object.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 0.1.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   	 * @example
   	 *
   	 * _.isFunction(_);
   	 * // => true
   	 *
   	 * _.isFunction(/abc/);
   	 * // => false
   	 */
   	function isFunction(value) {
   	  // The use of `Object#toString` avoids issues with the `typeof` operator
   	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
   	  var tag = isObject(value) ? objectToString.call(value) : '';
   	  return tag == funcTag || tag == genTag;
   	}

   	/**
   	 * Checks if `value` is a valid array-like length.
   	 *
   	 * **Note:** This method is loosely based on
   	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   	 * @example
   	 *
   	 * _.isLength(3);
   	 * // => true
   	 *
   	 * _.isLength(Number.MIN_VALUE);
   	 * // => false
   	 *
   	 * _.isLength(Infinity);
   	 * // => false
   	 *
   	 * _.isLength('3');
   	 * // => false
   	 */
   	function isLength(value) {
   	  return typeof value == 'number' &&
   	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
   	}

   	/**
   	 * Checks if `value` is the
   	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 0.1.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   	 * @example
   	 *
   	 * _.isObject({});
   	 * // => true
   	 *
   	 * _.isObject([1, 2, 3]);
   	 * // => true
   	 *
   	 * _.isObject(_.noop);
   	 * // => true
   	 *
   	 * _.isObject(null);
   	 * // => false
   	 */
   	function isObject(value) {
   	  var type = typeof value;
   	  return !!value && (type == 'object' || type == 'function');
   	}

   	/**
   	 * Checks if `value` is object-like. A value is object-like if it's not `null`
   	 * and has a `typeof` result of "object".
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   	 * @example
   	 *
   	 * _.isObjectLike({});
   	 * // => true
   	 *
   	 * _.isObjectLike([1, 2, 3]);
   	 * // => true
   	 *
   	 * _.isObjectLike(_.noop);
   	 * // => false
   	 *
   	 * _.isObjectLike(null);
   	 * // => false
   	 */
   	function isObjectLike(value) {
   	  return !!value && typeof value == 'object';
   	}

   	/**
   	 * Checks if `value` is classified as a `String` primitive or object.
   	 *
   	 * @static
   	 * @since 0.1.0
   	 * @memberOf _
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
   	 * @example
   	 *
   	 * _.isString('abc');
   	 * // => true
   	 *
   	 * _.isString(1);
   	 * // => false
   	 */
   	function isString(value) {
   	  return typeof value == 'string' ||
   	    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
   	}

   	/**
   	 * Checks if `value` is classified as a `Symbol` primitive or object.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   	 * @example
   	 *
   	 * _.isSymbol(Symbol.iterator);
   	 * // => true
   	 *
   	 * _.isSymbol('abc');
   	 * // => false
   	 */
   	function isSymbol(value) {
   	  return typeof value == 'symbol' ||
   	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
   	}

   	/**
   	 * Converts `value` to a finite number.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.12.0
   	 * @category Lang
   	 * @param {*} value The value to convert.
   	 * @returns {number} Returns the converted number.
   	 * @example
   	 *
   	 * _.toFinite(3.2);
   	 * // => 3.2
   	 *
   	 * _.toFinite(Number.MIN_VALUE);
   	 * // => 5e-324
   	 *
   	 * _.toFinite(Infinity);
   	 * // => 1.7976931348623157e+308
   	 *
   	 * _.toFinite('3.2');
   	 * // => 3.2
   	 */
   	function toFinite(value) {
   	  if (!value) {
   	    return value === 0 ? value : 0;
   	  }
   	  value = toNumber(value);
   	  if (value === INFINITY || value === -INFINITY) {
   	    var sign = (value < 0 ? -1 : 1);
   	    return sign * MAX_INTEGER;
   	  }
   	  return value === value ? value : 0;
   	}

   	/**
   	 * Converts `value` to an integer.
   	 *
   	 * **Note:** This method is loosely based on
   	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to convert.
   	 * @returns {number} Returns the converted integer.
   	 * @example
   	 *
   	 * _.toInteger(3.2);
   	 * // => 3
   	 *
   	 * _.toInteger(Number.MIN_VALUE);
   	 * // => 0
   	 *
   	 * _.toInteger(Infinity);
   	 * // => 1.7976931348623157e+308
   	 *
   	 * _.toInteger('3.2');
   	 * // => 3
   	 */
   	function toInteger(value) {
   	  var result = toFinite(value),
   	      remainder = result % 1;

   	  return result === result ? (remainder ? result - remainder : result) : 0;
   	}

   	/**
   	 * Converts `value` to a number.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to process.
   	 * @returns {number} Returns the number.
   	 * @example
   	 *
   	 * _.toNumber(3.2);
   	 * // => 3.2
   	 *
   	 * _.toNumber(Number.MIN_VALUE);
   	 * // => 5e-324
   	 *
   	 * _.toNumber(Infinity);
   	 * // => Infinity
   	 *
   	 * _.toNumber('3.2');
   	 * // => 3.2
   	 */
   	function toNumber(value) {
   	  if (typeof value == 'number') {
   	    return value;
   	  }
   	  if (isSymbol(value)) {
   	    return NAN;
   	  }
   	  if (isObject(value)) {
   	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
   	    value = isObject(other) ? (other + '') : other;
   	  }
   	  if (typeof value != 'string') {
   	    return value === 0 ? value : +value;
   	  }
   	  value = value.replace(reTrim, '');
   	  var isBinary = reIsBinary.test(value);
   	  return (isBinary || reIsOctal.test(value))
   	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
   	    : (reIsBadHex.test(value) ? NAN : +value);
   	}

   	/**
   	 * Creates an array of the own enumerable property names of `object`.
   	 *
   	 * **Note:** Non-object values are coerced to objects. See the
   	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   	 * for more details.
   	 *
   	 * @static
   	 * @since 0.1.0
   	 * @memberOf _
   	 * @category Object
   	 * @param {Object} object The object to query.
   	 * @returns {Array} Returns the array of property names.
   	 * @example
   	 *
   	 * function Foo() {
   	 *   this.a = 1;
   	 *   this.b = 2;
   	 * }
   	 *
   	 * Foo.prototype.c = 3;
   	 *
   	 * _.keys(new Foo);
   	 * // => ['a', 'b'] (iteration order is not guaranteed)
   	 *
   	 * _.keys('hi');
   	 * // => ['0', '1']
   	 */
   	function keys(object) {
   	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
   	}

   	/**
   	 * Creates an array of the own enumerable string keyed property values of `object`.
   	 *
   	 * **Note:** Non-object values are coerced to objects.
   	 *
   	 * @static
   	 * @since 0.1.0
   	 * @memberOf _
   	 * @category Object
   	 * @param {Object} object The object to query.
   	 * @returns {Array} Returns the array of property values.
   	 * @example
   	 *
   	 * function Foo() {
   	 *   this.a = 1;
   	 *   this.b = 2;
   	 * }
   	 *
   	 * Foo.prototype.c = 3;
   	 *
   	 * _.values(new Foo);
   	 * // => [1, 2] (iteration order is not guaranteed)
   	 *
   	 * _.values('hi');
   	 * // => ['h', 'i']
   	 */
   	function values(object) {
   	  return object ? baseValues(object, keys(object)) : [];
   	}

   	lodash_includes = includes;
   	return lodash_includes;
   }

   /**
    * lodash 3.0.3 (Custom Build) <https://lodash.com/>
    * Build: `lodash modularize exports="npm" -o ./`
    * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
    * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
    * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    * Available under MIT license <https://lodash.com/license>
    */

   var lodash_isboolean;
   var hasRequiredLodash_isboolean;

   function requireLodash_isboolean () {
   	if (hasRequiredLodash_isboolean) return lodash_isboolean;
   	hasRequiredLodash_isboolean = 1;
   	/** `Object#toString` result references. */
   	var boolTag = '[object Boolean]';

   	/** Used for built-in method references. */
   	var objectProto = Object.prototype;

   	/**
   	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
   	 * of values.
   	 */
   	var objectToString = objectProto.toString;

   	/**
   	 * Checks if `value` is classified as a boolean primitive or object.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   	 * @example
   	 *
   	 * _.isBoolean(false);
   	 * // => true
   	 *
   	 * _.isBoolean(null);
   	 * // => false
   	 */
   	function isBoolean(value) {
   	  return value === true || value === false ||
   	    (isObjectLike(value) && objectToString.call(value) == boolTag);
   	}

   	/**
   	 * Checks if `value` is object-like. A value is object-like if it's not `null`
   	 * and has a `typeof` result of "object".
   	 *
   	 * @static
   	 * @memberOf _
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   	 * @example
   	 *
   	 * _.isObjectLike({});
   	 * // => true
   	 *
   	 * _.isObjectLike([1, 2, 3]);
   	 * // => true
   	 *
   	 * _.isObjectLike(_.noop);
   	 * // => false
   	 *
   	 * _.isObjectLike(null);
   	 * // => false
   	 */
   	function isObjectLike(value) {
   	  return !!value && typeof value == 'object';
   	}

   	lodash_isboolean = isBoolean;
   	return lodash_isboolean;
   }

   /**
    * lodash (Custom Build) <https://lodash.com/>
    * Build: `lodash modularize exports="npm" -o ./`
    * Copyright jQuery Foundation and other contributors <https://jquery.org/>
    * Released under MIT license <https://lodash.com/license>
    * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
    * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    */

   var lodash_isinteger;
   var hasRequiredLodash_isinteger;

   function requireLodash_isinteger () {
   	if (hasRequiredLodash_isinteger) return lodash_isinteger;
   	hasRequiredLodash_isinteger = 1;
   	/** Used as references for various `Number` constants. */
   	var INFINITY = 1 / 0,
   	    MAX_INTEGER = 1.7976931348623157e+308,
   	    NAN = 0 / 0;

   	/** `Object#toString` result references. */
   	var symbolTag = '[object Symbol]';

   	/** Used to match leading and trailing whitespace. */
   	var reTrim = /^\s+|\s+$/g;

   	/** Used to detect bad signed hexadecimal string values. */
   	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

   	/** Used to detect binary string values. */
   	var reIsBinary = /^0b[01]+$/i;

   	/** Used to detect octal string values. */
   	var reIsOctal = /^0o[0-7]+$/i;

   	/** Built-in method references without a dependency on `root`. */
   	var freeParseInt = parseInt;

   	/** Used for built-in method references. */
   	var objectProto = Object.prototype;

   	/**
   	 * Used to resolve the
   	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   	 * of values.
   	 */
   	var objectToString = objectProto.toString;

   	/**
   	 * Checks if `value` is an integer.
   	 *
   	 * **Note:** This method is based on
   	 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
   	 * @example
   	 *
   	 * _.isInteger(3);
   	 * // => true
   	 *
   	 * _.isInteger(Number.MIN_VALUE);
   	 * // => false
   	 *
   	 * _.isInteger(Infinity);
   	 * // => false
   	 *
   	 * _.isInteger('3');
   	 * // => false
   	 */
   	function isInteger(value) {
   	  return typeof value == 'number' && value == toInteger(value);
   	}

   	/**
   	 * Checks if `value` is the
   	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 0.1.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   	 * @example
   	 *
   	 * _.isObject({});
   	 * // => true
   	 *
   	 * _.isObject([1, 2, 3]);
   	 * // => true
   	 *
   	 * _.isObject(_.noop);
   	 * // => true
   	 *
   	 * _.isObject(null);
   	 * // => false
   	 */
   	function isObject(value) {
   	  var type = typeof value;
   	  return !!value && (type == 'object' || type == 'function');
   	}

   	/**
   	 * Checks if `value` is object-like. A value is object-like if it's not `null`
   	 * and has a `typeof` result of "object".
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   	 * @example
   	 *
   	 * _.isObjectLike({});
   	 * // => true
   	 *
   	 * _.isObjectLike([1, 2, 3]);
   	 * // => true
   	 *
   	 * _.isObjectLike(_.noop);
   	 * // => false
   	 *
   	 * _.isObjectLike(null);
   	 * // => false
   	 */
   	function isObjectLike(value) {
   	  return !!value && typeof value == 'object';
   	}

   	/**
   	 * Checks if `value` is classified as a `Symbol` primitive or object.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   	 * @example
   	 *
   	 * _.isSymbol(Symbol.iterator);
   	 * // => true
   	 *
   	 * _.isSymbol('abc');
   	 * // => false
   	 */
   	function isSymbol(value) {
   	  return typeof value == 'symbol' ||
   	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
   	}

   	/**
   	 * Converts `value` to a finite number.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.12.0
   	 * @category Lang
   	 * @param {*} value The value to convert.
   	 * @returns {number} Returns the converted number.
   	 * @example
   	 *
   	 * _.toFinite(3.2);
   	 * // => 3.2
   	 *
   	 * _.toFinite(Number.MIN_VALUE);
   	 * // => 5e-324
   	 *
   	 * _.toFinite(Infinity);
   	 * // => 1.7976931348623157e+308
   	 *
   	 * _.toFinite('3.2');
   	 * // => 3.2
   	 */
   	function toFinite(value) {
   	  if (!value) {
   	    return value === 0 ? value : 0;
   	  }
   	  value = toNumber(value);
   	  if (value === INFINITY || value === -INFINITY) {
   	    var sign = (value < 0 ? -1 : 1);
   	    return sign * MAX_INTEGER;
   	  }
   	  return value === value ? value : 0;
   	}

   	/**
   	 * Converts `value` to an integer.
   	 *
   	 * **Note:** This method is loosely based on
   	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to convert.
   	 * @returns {number} Returns the converted integer.
   	 * @example
   	 *
   	 * _.toInteger(3.2);
   	 * // => 3
   	 *
   	 * _.toInteger(Number.MIN_VALUE);
   	 * // => 0
   	 *
   	 * _.toInteger(Infinity);
   	 * // => 1.7976931348623157e+308
   	 *
   	 * _.toInteger('3.2');
   	 * // => 3
   	 */
   	function toInteger(value) {
   	  var result = toFinite(value),
   	      remainder = result % 1;

   	  return result === result ? (remainder ? result - remainder : result) : 0;
   	}

   	/**
   	 * Converts `value` to a number.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to process.
   	 * @returns {number} Returns the number.
   	 * @example
   	 *
   	 * _.toNumber(3.2);
   	 * // => 3.2
   	 *
   	 * _.toNumber(Number.MIN_VALUE);
   	 * // => 5e-324
   	 *
   	 * _.toNumber(Infinity);
   	 * // => Infinity
   	 *
   	 * _.toNumber('3.2');
   	 * // => 3.2
   	 */
   	function toNumber(value) {
   	  if (typeof value == 'number') {
   	    return value;
   	  }
   	  if (isSymbol(value)) {
   	    return NAN;
   	  }
   	  if (isObject(value)) {
   	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
   	    value = isObject(other) ? (other + '') : other;
   	  }
   	  if (typeof value != 'string') {
   	    return value === 0 ? value : +value;
   	  }
   	  value = value.replace(reTrim, '');
   	  var isBinary = reIsBinary.test(value);
   	  return (isBinary || reIsOctal.test(value))
   	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
   	    : (reIsBadHex.test(value) ? NAN : +value);
   	}

   	lodash_isinteger = isInteger;
   	return lodash_isinteger;
   }

   /**
    * lodash 3.0.3 (Custom Build) <https://lodash.com/>
    * Build: `lodash modularize exports="npm" -o ./`
    * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
    * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
    * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    * Available under MIT license <https://lodash.com/license>
    */

   var lodash_isnumber;
   var hasRequiredLodash_isnumber;

   function requireLodash_isnumber () {
   	if (hasRequiredLodash_isnumber) return lodash_isnumber;
   	hasRequiredLodash_isnumber = 1;
   	/** `Object#toString` result references. */
   	var numberTag = '[object Number]';

   	/** Used for built-in method references. */
   	var objectProto = Object.prototype;

   	/**
   	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
   	 * of values.
   	 */
   	var objectToString = objectProto.toString;

   	/**
   	 * Checks if `value` is object-like. A value is object-like if it's not `null`
   	 * and has a `typeof` result of "object".
   	 *
   	 * @static
   	 * @memberOf _
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   	 * @example
   	 *
   	 * _.isObjectLike({});
   	 * // => true
   	 *
   	 * _.isObjectLike([1, 2, 3]);
   	 * // => true
   	 *
   	 * _.isObjectLike(_.noop);
   	 * // => false
   	 *
   	 * _.isObjectLike(null);
   	 * // => false
   	 */
   	function isObjectLike(value) {
   	  return !!value && typeof value == 'object';
   	}

   	/**
   	 * Checks if `value` is classified as a `Number` primitive or object.
   	 *
   	 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
   	 * as numbers, use the `_.isFinite` method.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   	 * @example
   	 *
   	 * _.isNumber(3);
   	 * // => true
   	 *
   	 * _.isNumber(Number.MIN_VALUE);
   	 * // => true
   	 *
   	 * _.isNumber(Infinity);
   	 * // => true
   	 *
   	 * _.isNumber('3');
   	 * // => false
   	 */
   	function isNumber(value) {
   	  return typeof value == 'number' ||
   	    (isObjectLike(value) && objectToString.call(value) == numberTag);
   	}

   	lodash_isnumber = isNumber;
   	return lodash_isnumber;
   }

   /**
    * lodash (Custom Build) <https://lodash.com/>
    * Build: `lodash modularize exports="npm" -o ./`
    * Copyright jQuery Foundation and other contributors <https://jquery.org/>
    * Released under MIT license <https://lodash.com/license>
    * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
    * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    */

   var lodash_isplainobject;
   var hasRequiredLodash_isplainobject;

   function requireLodash_isplainobject () {
   	if (hasRequiredLodash_isplainobject) return lodash_isplainobject;
   	hasRequiredLodash_isplainobject = 1;
   	/** `Object#toString` result references. */
   	var objectTag = '[object Object]';

   	/**
   	 * Checks if `value` is a host object in IE < 9.
   	 *
   	 * @private
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
   	 */
   	function isHostObject(value) {
   	  // Many host objects are `Object` objects that can coerce to strings
   	  // despite having improperly defined `toString` methods.
   	  var result = false;
   	  if (value != null && typeof value.toString != 'function') {
   	    try {
   	      result = !!(value + '');
   	    } catch (e) {}
   	  }
   	  return result;
   	}

   	/**
   	 * Creates a unary function that invokes `func` with its argument transformed.
   	 *
   	 * @private
   	 * @param {Function} func The function to wrap.
   	 * @param {Function} transform The argument transform.
   	 * @returns {Function} Returns the new function.
   	 */
   	function overArg(func, transform) {
   	  return function(arg) {
   	    return func(transform(arg));
   	  };
   	}

   	/** Used for built-in method references. */
   	var funcProto = Function.prototype,
   	    objectProto = Object.prototype;

   	/** Used to resolve the decompiled source of functions. */
   	var funcToString = funcProto.toString;

   	/** Used to check objects for own properties. */
   	var hasOwnProperty = objectProto.hasOwnProperty;

   	/** Used to infer the `Object` constructor. */
   	var objectCtorString = funcToString.call(Object);

   	/**
   	 * Used to resolve the
   	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   	 * of values.
   	 */
   	var objectToString = objectProto.toString;

   	/** Built-in value references. */
   	var getPrototype = overArg(Object.getPrototypeOf, Object);

   	/**
   	 * Checks if `value` is object-like. A value is object-like if it's not `null`
   	 * and has a `typeof` result of "object".
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   	 * @example
   	 *
   	 * _.isObjectLike({});
   	 * // => true
   	 *
   	 * _.isObjectLike([1, 2, 3]);
   	 * // => true
   	 *
   	 * _.isObjectLike(_.noop);
   	 * // => false
   	 *
   	 * _.isObjectLike(null);
   	 * // => false
   	 */
   	function isObjectLike(value) {
   	  return !!value && typeof value == 'object';
   	}

   	/**
   	 * Checks if `value` is a plain object, that is, an object created by the
   	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 0.8.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   	 * @example
   	 *
   	 * function Foo() {
   	 *   this.a = 1;
   	 * }
   	 *
   	 * _.isPlainObject(new Foo);
   	 * // => false
   	 *
   	 * _.isPlainObject([1, 2, 3]);
   	 * // => false
   	 *
   	 * _.isPlainObject({ 'x': 0, 'y': 0 });
   	 * // => true
   	 *
   	 * _.isPlainObject(Object.create(null));
   	 * // => true
   	 */
   	function isPlainObject(value) {
   	  if (!isObjectLike(value) ||
   	      objectToString.call(value) != objectTag || isHostObject(value)) {
   	    return false;
   	  }
   	  var proto = getPrototype(value);
   	  if (proto === null) {
   	    return true;
   	  }
   	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
   	  return (typeof Ctor == 'function' &&
   	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
   	}

   	lodash_isplainobject = isPlainObject;
   	return lodash_isplainobject;
   }

   /**
    * lodash 4.0.1 (Custom Build) <https://lodash.com/>
    * Build: `lodash modularize exports="npm" -o ./`
    * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
    * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
    * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    * Available under MIT license <https://lodash.com/license>
    */

   var lodash_isstring;
   var hasRequiredLodash_isstring;

   function requireLodash_isstring () {
   	if (hasRequiredLodash_isstring) return lodash_isstring;
   	hasRequiredLodash_isstring = 1;
   	/** `Object#toString` result references. */
   	var stringTag = '[object String]';

   	/** Used for built-in method references. */
   	var objectProto = Object.prototype;

   	/**
   	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
   	 * of values.
   	 */
   	var objectToString = objectProto.toString;

   	/**
   	 * Checks if `value` is classified as an `Array` object.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @type Function
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   	 * @example
   	 *
   	 * _.isArray([1, 2, 3]);
   	 * // => true
   	 *
   	 * _.isArray(document.body.children);
   	 * // => false
   	 *
   	 * _.isArray('abc');
   	 * // => false
   	 *
   	 * _.isArray(_.noop);
   	 * // => false
   	 */
   	var isArray = Array.isArray;

   	/**
   	 * Checks if `value` is object-like. A value is object-like if it's not `null`
   	 * and has a `typeof` result of "object".
   	 *
   	 * @static
   	 * @memberOf _
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   	 * @example
   	 *
   	 * _.isObjectLike({});
   	 * // => true
   	 *
   	 * _.isObjectLike([1, 2, 3]);
   	 * // => true
   	 *
   	 * _.isObjectLike(_.noop);
   	 * // => false
   	 *
   	 * _.isObjectLike(null);
   	 * // => false
   	 */
   	function isObjectLike(value) {
   	  return !!value && typeof value == 'object';
   	}

   	/**
   	 * Checks if `value` is classified as a `String` primitive or object.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   	 * @example
   	 *
   	 * _.isString('abc');
   	 * // => true
   	 *
   	 * _.isString(1);
   	 * // => false
   	 */
   	function isString(value) {
   	  return typeof value == 'string' ||
   	    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
   	}

   	lodash_isstring = isString;
   	return lodash_isstring;
   }

   /**
    * lodash (Custom Build) <https://lodash.com/>
    * Build: `lodash modularize exports="npm" -o ./`
    * Copyright jQuery Foundation and other contributors <https://jquery.org/>
    * Released under MIT license <https://lodash.com/license>
    * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
    * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    */

   var lodash_once;
   var hasRequiredLodash_once;

   function requireLodash_once () {
   	if (hasRequiredLodash_once) return lodash_once;
   	hasRequiredLodash_once = 1;
   	/** Used as the `TypeError` message for "Functions" methods. */
   	var FUNC_ERROR_TEXT = 'Expected a function';

   	/** Used as references for various `Number` constants. */
   	var INFINITY = 1 / 0,
   	    MAX_INTEGER = 1.7976931348623157e+308,
   	    NAN = 0 / 0;

   	/** `Object#toString` result references. */
   	var symbolTag = '[object Symbol]';

   	/** Used to match leading and trailing whitespace. */
   	var reTrim = /^\s+|\s+$/g;

   	/** Used to detect bad signed hexadecimal string values. */
   	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

   	/** Used to detect binary string values. */
   	var reIsBinary = /^0b[01]+$/i;

   	/** Used to detect octal string values. */
   	var reIsOctal = /^0o[0-7]+$/i;

   	/** Built-in method references without a dependency on `root`. */
   	var freeParseInt = parseInt;

   	/** Used for built-in method references. */
   	var objectProto = Object.prototype;

   	/**
   	 * Used to resolve the
   	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   	 * of values.
   	 */
   	var objectToString = objectProto.toString;

   	/**
   	 * Creates a function that invokes `func`, with the `this` binding and arguments
   	 * of the created function, while it's called less than `n` times. Subsequent
   	 * calls to the created function return the result of the last `func` invocation.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 3.0.0
   	 * @category Function
   	 * @param {number} n The number of calls at which `func` is no longer invoked.
   	 * @param {Function} func The function to restrict.
   	 * @returns {Function} Returns the new restricted function.
   	 * @example
   	 *
   	 * jQuery(element).on('click', _.before(5, addContactToList));
   	 * // => Allows adding up to 4 contacts to the list.
   	 */
   	function before(n, func) {
   	  var result;
   	  if (typeof func != 'function') {
   	    throw new TypeError(FUNC_ERROR_TEXT);
   	  }
   	  n = toInteger(n);
   	  return function() {
   	    if (--n > 0) {
   	      result = func.apply(this, arguments);
   	    }
   	    if (n <= 1) {
   	      func = undefined;
   	    }
   	    return result;
   	  };
   	}

   	/**
   	 * Creates a function that is restricted to invoking `func` once. Repeat calls
   	 * to the function return the value of the first invocation. The `func` is
   	 * invoked with the `this` binding and arguments of the created function.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 0.1.0
   	 * @category Function
   	 * @param {Function} func The function to restrict.
   	 * @returns {Function} Returns the new restricted function.
   	 * @example
   	 *
   	 * var initialize = _.once(createApplication);
   	 * initialize();
   	 * initialize();
   	 * // => `createApplication` is invoked once
   	 */
   	function once(func) {
   	  return before(2, func);
   	}

   	/**
   	 * Checks if `value` is the
   	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 0.1.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   	 * @example
   	 *
   	 * _.isObject({});
   	 * // => true
   	 *
   	 * _.isObject([1, 2, 3]);
   	 * // => true
   	 *
   	 * _.isObject(_.noop);
   	 * // => true
   	 *
   	 * _.isObject(null);
   	 * // => false
   	 */
   	function isObject(value) {
   	  var type = typeof value;
   	  return !!value && (type == 'object' || type == 'function');
   	}

   	/**
   	 * Checks if `value` is object-like. A value is object-like if it's not `null`
   	 * and has a `typeof` result of "object".
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   	 * @example
   	 *
   	 * _.isObjectLike({});
   	 * // => true
   	 *
   	 * _.isObjectLike([1, 2, 3]);
   	 * // => true
   	 *
   	 * _.isObjectLike(_.noop);
   	 * // => false
   	 *
   	 * _.isObjectLike(null);
   	 * // => false
   	 */
   	function isObjectLike(value) {
   	  return !!value && typeof value == 'object';
   	}

   	/**
   	 * Checks if `value` is classified as a `Symbol` primitive or object.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to check.
   	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   	 * @example
   	 *
   	 * _.isSymbol(Symbol.iterator);
   	 * // => true
   	 *
   	 * _.isSymbol('abc');
   	 * // => false
   	 */
   	function isSymbol(value) {
   	  return typeof value == 'symbol' ||
   	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
   	}

   	/**
   	 * Converts `value` to a finite number.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.12.0
   	 * @category Lang
   	 * @param {*} value The value to convert.
   	 * @returns {number} Returns the converted number.
   	 * @example
   	 *
   	 * _.toFinite(3.2);
   	 * // => 3.2
   	 *
   	 * _.toFinite(Number.MIN_VALUE);
   	 * // => 5e-324
   	 *
   	 * _.toFinite(Infinity);
   	 * // => 1.7976931348623157e+308
   	 *
   	 * _.toFinite('3.2');
   	 * // => 3.2
   	 */
   	function toFinite(value) {
   	  if (!value) {
   	    return value === 0 ? value : 0;
   	  }
   	  value = toNumber(value);
   	  if (value === INFINITY || value === -INFINITY) {
   	    var sign = (value < 0 ? -1 : 1);
   	    return sign * MAX_INTEGER;
   	  }
   	  return value === value ? value : 0;
   	}

   	/**
   	 * Converts `value` to an integer.
   	 *
   	 * **Note:** This method is loosely based on
   	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to convert.
   	 * @returns {number} Returns the converted integer.
   	 * @example
   	 *
   	 * _.toInteger(3.2);
   	 * // => 3
   	 *
   	 * _.toInteger(Number.MIN_VALUE);
   	 * // => 0
   	 *
   	 * _.toInteger(Infinity);
   	 * // => 1.7976931348623157e+308
   	 *
   	 * _.toInteger('3.2');
   	 * // => 3
   	 */
   	function toInteger(value) {
   	  var result = toFinite(value),
   	      remainder = result % 1;

   	  return result === result ? (remainder ? result - remainder : result) : 0;
   	}

   	/**
   	 * Converts `value` to a number.
   	 *
   	 * @static
   	 * @memberOf _
   	 * @since 4.0.0
   	 * @category Lang
   	 * @param {*} value The value to process.
   	 * @returns {number} Returns the number.
   	 * @example
   	 *
   	 * _.toNumber(3.2);
   	 * // => 3.2
   	 *
   	 * _.toNumber(Number.MIN_VALUE);
   	 * // => 5e-324
   	 *
   	 * _.toNumber(Infinity);
   	 * // => Infinity
   	 *
   	 * _.toNumber('3.2');
   	 * // => 3.2
   	 */
   	function toNumber(value) {
   	  if (typeof value == 'number') {
   	    return value;
   	  }
   	  if (isSymbol(value)) {
   	    return NAN;
   	  }
   	  if (isObject(value)) {
   	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
   	    value = isObject(other) ? (other + '') : other;
   	  }
   	  if (typeof value != 'string') {
   	    return value === 0 ? value : +value;
   	  }
   	  value = value.replace(reTrim, '');
   	  var isBinary = reIsBinary.test(value);
   	  return (isBinary || reIsOctal.test(value))
   	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
   	    : (reIsBadHex.test(value) ? NAN : +value);
   	}

   	lodash_once = once;
   	return lodash_once;
   }

   var sign;
   var hasRequiredSign;

   function requireSign () {
   	if (hasRequiredSign) return sign;
   	hasRequiredSign = 1;
   	const timespan = requireTimespan();
   	const PS_SUPPORTED = requirePsSupported();
   	const validateAsymmetricKey = requireValidateAsymmetricKey();
   	const jws = requireJws();
   	const includes = requireLodash_includes();
   	const isBoolean = requireLodash_isboolean();
   	const isInteger = requireLodash_isinteger();
   	const isNumber = requireLodash_isnumber();
   	const isPlainObject = requireLodash_isplainobject();
   	const isString = requireLodash_isstring();
   	const once = requireLodash_once();
   	const { KeyObject, createSecretKey, createPrivateKey } = require$$1;

   	const SUPPORTED_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none'];
   	if (PS_SUPPORTED) {
   	  SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');
   	}

   	const sign_options_schema = {
   	  expiresIn: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
   	  notBefore: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
   	  audience: { isValid: function(value) { return isString(value) || Array.isArray(value); }, message: '"audience" must be a string or array' },
   	  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
   	  header: { isValid: isPlainObject, message: '"header" must be an object' },
   	  encoding: { isValid: isString, message: '"encoding" must be a string' },
   	  issuer: { isValid: isString, message: '"issuer" must be a string' },
   	  subject: { isValid: isString, message: '"subject" must be a string' },
   	  jwtid: { isValid: isString, message: '"jwtid" must be a string' },
   	  noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
   	  keyid: { isValid: isString, message: '"keyid" must be a string' },
   	  mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
   	  allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean'},
   	  allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean'}
   	};

   	const registered_claims_schema = {
   	  iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
   	  exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
   	  nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
   	};

   	function validate(schema, allowUnknown, object, parameterName) {
   	  if (!isPlainObject(object)) {
   	    throw new Error('Expected "' + parameterName + '" to be a plain object.');
   	  }
   	  Object.keys(object)
   	    .forEach(function(key) {
   	      const validator = schema[key];
   	      if (!validator) {
   	        if (!allowUnknown) {
   	          throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
   	        }
   	        return;
   	      }
   	      if (!validator.isValid(object[key])) {
   	        throw new Error(validator.message);
   	      }
   	    });
   	}

   	function validateOptions(options) {
   	  return validate(sign_options_schema, false, options, 'options');
   	}

   	function validatePayload(payload) {
   	  return validate(registered_claims_schema, true, payload, 'payload');
   	}

   	const options_to_payload = {
   	  'audience': 'aud',
   	  'issuer': 'iss',
   	  'subject': 'sub',
   	  'jwtid': 'jti'
   	};

   	const options_for_objects = [
   	  'expiresIn',
   	  'notBefore',
   	  'noTimestamp',
   	  'audience',
   	  'issuer',
   	  'subject',
   	  'jwtid',
   	];

   	sign = function (payload, secretOrPrivateKey, options, callback) {
   	  if (typeof options === 'function') {
   	    callback = options;
   	    options = {};
   	  } else {
   	    options = options || {};
   	  }

   	  const isObjectPayload = typeof payload === 'object' &&
   	                        !Buffer.isBuffer(payload);

   	  const header = Object.assign({
   	    alg: options.algorithm || 'HS256',
   	    typ: isObjectPayload ? 'JWT' : undefined,
   	    kid: options.keyid
   	  }, options.header);

   	  function failure(err) {
   	    if (callback) {
   	      return callback(err);
   	    }
   	    throw err;
   	  }

   	  if (!secretOrPrivateKey && options.algorithm !== 'none') {
   	    return failure(new Error('secretOrPrivateKey must have a value'));
   	  }

   	  if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
   	    try {
   	      secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
   	    } catch (_) {
   	      try {
   	        secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === 'string' ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
   	      } catch (_) {
   	        return failure(new Error('secretOrPrivateKey is not valid key material'));
   	      }
   	    }
   	  }

   	  if (header.alg.startsWith('HS') && secretOrPrivateKey.type !== 'secret') {
   	    return failure(new Error((`secretOrPrivateKey must be a symmetric key when using ${header.alg}`)))
   	  } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
   	    if (secretOrPrivateKey.type !== 'private') {
   	      return failure(new Error((`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`)))
   	    }
   	    if (!options.allowInsecureKeySizes &&
   	      !header.alg.startsWith('ES') &&
   	      secretOrPrivateKey.asymmetricKeyDetails !== undefined && //KeyObject.asymmetricKeyDetails is supported in Node 15+
   	      secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
   	      return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
   	    }
   	  }

   	  if (typeof payload === 'undefined') {
   	    return failure(new Error('payload is required'));
   	  } else if (isObjectPayload) {
   	    try {
   	      validatePayload(payload);
   	    }
   	    catch (error) {
   	      return failure(error);
   	    }
   	    if (!options.mutatePayload) {
   	      payload = Object.assign({},payload);
   	    }
   	  } else {
   	    const invalid_options = options_for_objects.filter(function (opt) {
   	      return typeof options[opt] !== 'undefined';
   	    });

   	    if (invalid_options.length > 0) {
   	      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));
   	    }
   	  }

   	  if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {
   	    return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
   	  }

   	  if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {
   	    return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
   	  }

   	  try {
   	    validateOptions(options);
   	  }
   	  catch (error) {
   	    return failure(error);
   	  }

   	  if (!options.allowInvalidAsymmetricKeyTypes) {
   	    try {
   	      validateAsymmetricKey(header.alg, secretOrPrivateKey);
   	    } catch (error) {
   	      return failure(error);
   	    }
   	  }

   	  const timestamp = payload.iat || Math.floor(Date.now() / 1000);

   	  if (options.noTimestamp) {
   	    delete payload.iat;
   	  } else if (isObjectPayload) {
   	    payload.iat = timestamp;
   	  }

   	  if (typeof options.notBefore !== 'undefined') {
   	    try {
   	      payload.nbf = timespan(options.notBefore, timestamp);
   	    }
   	    catch (err) {
   	      return failure(err);
   	    }
   	    if (typeof payload.nbf === 'undefined') {
   	      return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
   	    }
   	  }

   	  if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {
   	    try {
   	      payload.exp = timespan(options.expiresIn, timestamp);
   	    }
   	    catch (err) {
   	      return failure(err);
   	    }
   	    if (typeof payload.exp === 'undefined') {
   	      return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
   	    }
   	  }

   	  Object.keys(options_to_payload).forEach(function (key) {
   	    const claim = options_to_payload[key];
   	    if (typeof options[key] !== 'undefined') {
   	      if (typeof payload[claim] !== 'undefined') {
   	        return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
   	      }
   	      payload[claim] = options[key];
   	    }
   	  });

   	  const encoding = options.encoding || 'utf8';

   	  if (typeof callback === 'function') {
   	    callback = callback && once(callback);

   	    jws.createSign({
   	      header: header,
   	      privateKey: secretOrPrivateKey,
   	      payload: payload,
   	      encoding: encoding
   	    }).once('error', callback)
   	      .once('done', function (signature) {
   	        // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version
   	        if(!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
   	          return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`))
   	        }
   	        callback(null, signature);
   	      });
   	  } else {
   	    let signature = jws.sign({header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});
   	    // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version
   	    if(!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
   	      throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`)
   	    }
   	    return signature
   	  }
   	};
   	return sign;
   }

   var jsonwebtoken;
   var hasRequiredJsonwebtoken;

   function requireJsonwebtoken () {
   	if (hasRequiredJsonwebtoken) return jsonwebtoken;
   	hasRequiredJsonwebtoken = 1;
   	jsonwebtoken = {
   	  decode: requireDecode(),
   	  verify: requireVerify(),
   	  sign: requireSign(),
   	  JsonWebTokenError: requireJsonWebTokenError(),
   	  NotBeforeError: requireNotBeforeError(),
   	  TokenExpiredError: requireTokenExpiredError(),
   	};
   	return jsonwebtoken;
   }

   var jsonwebtokenExports = requireJsonwebtoken();
   var jwt = /*@__PURE__*/getDefaultExportFromCjs(jsonwebtokenExports);

   (function () {
       const TRACKING_ENDPOINT = "https://affiliate-marketing-ten.vercel.app/api/track";
       const ORGID_ENDPOINT = "https://affiliate-marketing-ten.vercel.app/api/org";
       const REF_KEYS = ["ref", "aff", "via"];
       function convertToSeconds(value, unit) {
           const unitToSeconds = {
               second: 1,
               minute: 60,
               hour: 3600,
               day: 86400,
               week: 604800,
               month: 2592000,
               year: 31536000,
           };
           return value * (unitToSeconds[unit.toLowerCase()] || 86400);
       }
       async function storeRefCode(code) {
           try {
               const res = await fetch(`${ORGID_ENDPOINT}/?code=${encodeURIComponent(code)}`);
               if (!res.ok)
                   throw new Error("Failed to fetch organization info");
               const { cookieLifetimeValue, cookieLifetimeUnit, commissionType, commissionValue, commissionDurationValue, commissionDurationUnit, } = await res.json();
               const maxAge = convertToSeconds(cookieLifetimeValue, cookieLifetimeUnit);
               const affiliateData = {
                   code,
                   commissionType,
                   commissionValue,
                   commissionDurationValue,
                   commissionDurationUnit,
               };
               const token = jwt.sign(affiliateData, process.env.SECRET_KEY);
               document.cookie = `refearnapp_affiliate_token=${encodeURIComponent(token)}; path=/; max-age=${maxAge};`;
           }
           catch (err) {
               console.error("Failed to set affiliate cookie:", err);
           }
       }
       function getReferralCode() {
           const urlParams = new URLSearchParams(window.location.search);
           for (const key of REF_KEYS) {
               if (urlParams.has(key))
                   return urlParams.get(key);
           }
           return null;
       }
       function getCookie(name) {
           return document.cookie
               .split("; ")
               .find((row) => row.startsWith(name + "="));
       }
       function setTempClickCookie() {
           document.cookie = `refearnapp_affiliate_click_tracked=true; max-age=86400; path=/`;
       }
       function getDeviceInfo() {
           const parser = new UAParser();
           const result = parser.getResult();
           return {
               browser: result.browser.name,
               os: result.os.name,
               deviceType: result.device.type || "desktop",
           };
       }
       function sendTrackingData(data) {
           const payload = JSON.stringify(data);
           const sent = navigator.sendBeacon(TRACKING_ENDPOINT, payload);
           if (!sent) {
               fetch(TRACKING_ENDPOINT, {
                   method: "POST",
                   headers: { "Content-Type": "application/json" },
                   body: payload,
                   keepalive: true,
               }).catch(() => { });
           }
       }
       // ð¥ Only this is needed â track on landing
       const refCode = getReferralCode();
       if (refCode && !getCookie("refearnapp_affiliate_click_tracked")) {
           storeRefCode(refCode)
               .then(() => {
               sendTrackingData(Object.assign({ ref: refCode, referrer: document.referrer, userAgent: navigator.userAgent, url: window.location.href }, getDeviceInfo()));
               setTempClickCookie();
           })
               .catch((err) => {
               console.error("Failed to process affiliate tracking:", err);
           });
       }
   })();

})(require$$0, require$$3, require$$5, require$$1);
//# sourceMappingURL=affiliateTrackingJavascript.js.map
